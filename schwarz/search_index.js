var documenterSearchIndex = {"docs":
[{"location":"PlasmoSchwarz/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart gives a brief overview of the functions needed for using PlasmoSchwarz to solve optimization problems defined in Plasmo. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Once PlasmoSchwarz has been installed, you can use it from a Julia session using ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using PlasmoSchwarz","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz also requires defining a graph with Plasmo, and we will need a solver for the subproblems. We will use Ipopt. These packages will also need to be loaded","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using Plasmo, Ipopt","category":"page"},{"location":"PlasmoSchwarz/quickstart/#PlasmoSchwarz-Overview","page":"Quickstart","title":"PlasmoSchwarz Overview","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz is an iterative algorithm that solves overlapping subproblems and then shares information between the subproblems to help converge to the overall solution. The structure that PlasmoSchwarz \"sees\" is either defined by the user by partitioning into subgraphs or the partitioning can be done automatically using packages like Metis.jl or KaHyPar. The graph is passed to the SchwarzAlgorithm function which overlaps the graphs and updates the graphs as needed to apply Schwarz Decomposition. Schwarz Decomposition can then be applied by calling run_algorithm!. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/#Optimal-Control-Example","page":"Quickstart","title":"Optimal Control Example","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"To show how PlasmoSchwarz can be applied for solving a problem, we will show a simple example of an optimal control problem over 200 time steps. The problem can be written as ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"beginalign* \n    min  sum_t in mathcalT x_t^2 + u_t^2\n    textrmst  x_t+1 = x_t + u_t + d_t\n     x_0 = barx_o \n     x_t ge 0 \n     u_t ge underlineu\nendalign*","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, x are the states, u are the inputs, and d are disturbances. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start by importing the required packages and defining problem parameters","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Plasmo, Ipopt\nusing PlasmoSchwarz\n\nT = 200             # number of time points\nd = sin.(1:T)       # a disturbance vector\nimbalance = 0.1     # partition imbalance\ndistance = 2        # expansion distance\nn_parts = 10        # number of partitions","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Next, we will create the OptiGraph and nodes. Each state and input variable will be represented by a node.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# create the optigraph\ngraph = Plasmo.OptiGraph()\n@optinode(graph, state[1:T])\n@optinode(graph, control[1:(T - 1)])\nfor (i, node) in enumerate(state)\n    @variable(node, x)\n    @constraint(node, x >= 0)\n    @objective(node, Min, x^2)\nend\nfor node in control\n    @variable(node, u)\n    @constraint(node, u >= -1000)\n    @objective(node, Min, u^2)\nend","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Next, we will set the initial value of the state and then link the state variables to the previous state and inputs.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# initial condition\nn1 = state[1]\n@constraint(n1, n1[:x] == 0)\n\n# dynamics\nfor i in 1:(T - 1)\n    @linkconstraint(graph, state[i + 1][:x] == state[i][:x] + control[i][:u] + d[i])\nend","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Now, we can define the sub-solver that will be used on the individual subproblem subgraphs, and we can then construct the SchwarzAlgorithm object.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# subproblem optimizer\nsub_optimizer = Plasmo.optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\n\n# optimize using overlapping schwarz decomposition\noptimizer = SchwarzAlgorithm(\n    graph;\n    n_partitions=n_parts,\n    overlap_distance=1,\n    subproblem_optimizer=sub_optimizer,\n    max_iterations=100,\n    mu=10.0,\n)","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, we have not defined the partitions to be used, so the SchwarzAlgorithm function will do the partitioning internally using Metis.jl and then overlap each subgraph by a distance of 1. Now, we can run the algorithm by calling ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"run_algorithm!(optimizer)","category":"page"},{"location":"PlasmoSchwarz/quickstart/#Querying-Solutions","page":"Quickstart","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz.jl provides API functions for querying solutions and information from the SchwarzAlgorithm object. To query the objective value, termination status, or solve time, we can use","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Plasmo.objective_value(optimizer)\nPlasmo.termination_status(optimizer)\nPlasmo.solve_time(optimizer)","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"The primal and dual variables can be queried by calling value or dual with the first argument being the SchwarzAlgorithm object","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Plasmo.value(optmizer, state[1][:x])\ncons = all_constraints(graph)\nPlasmo.dual(optimizer, cons[1])","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"You can also access the primal and dual feasibility vectors by viewing the algorithm methods.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"prf = PlasmoSchwarz.calculate_primal_feasibility(optimizer)\nduf = PlasmoSchwarz.calculate_dual_feasibility(optimizer)","category":"page"},{"location":"PlasmoSchwarz/algorithm/#Solution-Algorithm-for-PlasmoSchwarz.jl","page":"Algorithm","title":"Solution Algorithm for PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Schwarz Decomposition is an iterative algorithm takes advantage of Plasmo.jl's subgraph structuring capabilities by partitioning an optimization problem into separate subgraphs. The subgraphs can then be expanded to overlap with other subgraphs, and a single iteration of the algorithm solves each subgraph, which can be done in parallel. After optimization, solutions around the overlapping regions are shared between subgraphs and used within the algorithm to help the subgraphs converge to the solution of the overall problem. Schwarz decomposition does not support integer variables. Further, in practice, convergence of PlasmoSchwarz is dependent on problem formulation and the degree of overlap between problems. Convergence is not guaranteed, but primal and dual values can be used to detect whether a local solution has been reached. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/#Schwarz-Decomposition","page":"Algorithm","title":"Schwarz Decomposition","text":"","category":"section"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Schwarz Decomposition can be applied to graph-structured problems defined in Plasmo.jl The overall graph structure in Plasmo.jl has the form","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  sum_n in mathcalN(mathcalG) f_n (x_n) \n    textrmst  x_n in mathcalX_n n in mathcalN(mathcalG) \n     g_e(x_n _n in mathcalN(e)) = 0 e in mathcalE(mathcalG)\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, x_n are the variables stored on node n, mathcalN(mathcalG) represents the set of nodes on graph mathcalG, mathcalE(mathcalG) represents the set of edges on graph mathcalG, and mathcalN(E) are the nodes connected by edge e. Thus, the first constraint set are the local constraints (stored on each node) and the second constraint set are the linking constraints for constraints on two or more nodes. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Further details of the algorithm can be found in the original Plasmo.jl paper here, but we will give an overview of the algorithm here. A graph mathcalG can be partitioned into N subgraphs notated by  mathcalSG_i ^N_i=1. These subgraphs can be expanded (meaning that they will now include nodes within a prescribed distance of nodes in the original subgraph) to obtain expanded subgraphs notated by  mathcalSG_i ^N_i=1. Under Schwarz Decomposition, the constraints on the incident edges of the expanded subgraphs can be enforced using the previous iteration's solutions from the adjacent subgraphs. The formulation for a given subgraph, mathcalSG_i is given by:","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  sum_n in mathcalN(mathcalSG_i) f_n (x_n) - sum_e in mathcalI_1(mathcalSG_i) (lambda_e^k)^top g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i)) \n    textrmst  x_n in mathcalX_n n in mathcalN(mathcalSG_i) \n     g_e(x_n _n in mathcalN(e)) = 0 e in mathcalE(mathcalSG_i) \n     g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i)) = 0 e in mathcalI_2(mathcalSG_i)\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, (cdot)^k denotes the iteration counter, lambda_e denotes the dual variable on their respective constraints, and mathcalI(mathcalSG_i) denotes the set of incident edges (i.e., edges which contain nodes in the overlapped subgraph and outside of the overlapped subgraph). The sets mathcalI_1 and mathcalI_2 denote how the incident linking constraints are formulated in the subproblem (as either primal or dual coupled). ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"In the thesis of Prof. Sungho Shin, it was also shown to improve convergence to include an augmented penalty term in the objective, and this is included in PlasmoSchwarz. The objective therefore also gets updated with the augmented term ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\nsum_e in mathcalI_1(mathcalSG_i) mu frac12 g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i))\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"where mu is a parameter that can be set by the user. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Convergence of the algorithm is determined by primal and dual infeasibility which is computed at each iteration. The primal feasibility is determined by the incident linking constraints being feasible between the different subproblems, and the dual infeasibility is determined by the difference in the dual variables of the link constraints in the overlapping regions. ","category":"page"},{"location":"#PlasmoAlgorithms.jl","page":"Introduction","title":"PlasmoAlgorithms.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is a library of decomposition approaches in Julia that have been implemented for Plasmo.jl data structures. Plasmo is an open-source modeling package that constructs graph-structured optimization models. Plasmo is built on an abstraction called an OptiGraph, containing OptiNodes (with objectives, variables, and constraints) and OptiEdges (with constraints for variables on two or more nodes). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is intended to include different decomposition approaches that can exploit the graph structure of an optimization, and the implementation of these algorithms is based upon the graph structure. Currently, the following are implemented in this repository: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Benders Decomposition is implemented through the package PlasmoBenders.jl that is contained in this repository. PlasmoBenders.jl applies Benders and Nested Benders Decompositions to a problem defined by the user in Plasmo. PlasmoBenders applies these decomposition approaches based on the structure defined by the graph, where the graph structure dictates the complicating variables for the algorithm. Benders can be used for LP and MILP problems.\nOverlapping Schwarz Decomposition is implemented throught he package PlasmoSchwarz.jl (formerly SchwarzOpt.jl). PlasmoSchwarz.jl uses a partitioned graph and overlaps the partitioned regions with their neighboring partitions. Each overlapped subgraph is optimized and information is then shared between the subgraphs. Overlapping Schwarz can be used for NLP problems. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other decomposition approaches could likewise be developed. We welcome contributions to the PlasmoAlgorithms suite. In addition, we encourage reporting issues and feature requests via the GitHub issue tracker..","category":"page"},{"location":"PlasmoSchwarz/api_docs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"PlasmoSchwarz/api_docs/#API-Manual","page":"API Documentation","title":"API Manual","text":"","category":"section"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.Options","page":"API Documentation","title":"PlasmoSchwarz.Options","text":"Options\n\nConfiguration options for the algorithm.\n\nFields:\n\ntolerance::Float64: Convergence tolerance for primal and dual errors (default: 1e-4).\nmax_iterations::Int64: Maximum number of iterations to run (default: 1000).\nmu::Float64: Penalty parameter for the augmented Lagrangian (default: 1.0).\noverlap_distance::Int64: Distance for overlap in subproblem expansion (default: 1).\nuse_node_objectives::Bool: Whether to use node-specific objectives instead of a global graph objective (default: true).\nsubproblem_optimizer: The optimizer to use for solving subproblems (default: nothing).\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SchwarzAlgorithm","page":"API Documentation","title":"PlasmoSchwarz.SchwarzAlgorithm","text":"SchwarzAlgorithm{GT<:Plasmo.AbstractOptiGraph}\n\nRepresents a Schwarz-based optimization algorithm applied to a partitioned graph.\n\nFields:\n\ngraph::GT: The global optimization graph passed to the algorithm.\nsubproblems::Vector{GT}: A list of subgraphs representing the (expanded) subproblems.\nelement_subproblem_map::Dict{Plasmo.OptiElement,GT}: Maps elements in the graph to their associated subproblems.\nobjective_func::Plasmo.AbstractJuMPScalar: The global objective function for the graph.\noptions::Options: Configuration options for the algorithm.\ninitialized::Bool: Whether the algorithm has been initialized.\nstatus::MOI.TerminationStatusCode: The current status of the algorithm.\nerr_pr::Union{Nothing,Float64}: Current primal error.\nerr_du::Union{Nothing,Float64}: Current dual error.\nobjective_value::Union{Nothing,Float64}: Current objective value.\niteration::Int64: Current iteration count.\nprimal_error_iters::Vector{Float64}: History of primal errors per iteration.\ndual_error_iters::Vector{Float64}: History of dual errors per iteration.\nobjective_iters::Vector{Float64}: History of objective values per iteration.\nsolve_time::Float64: Total solve time.\ntimers::Timers: Timers to measure performance metrics.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SchwarzAlgorithm-Tuple{OptiGraph, Vector{OptiGraph}}","page":"API Documentation","title":"PlasmoSchwarz.SchwarzAlgorithm","text":"SchwarzAlgorithm(graph::OptiGraph, expanded_subgraphs::Vector{OptiGraph}; kwargs...)\n\nCreate an algorithm instance by providing the subproblems directly.\n\nSchwarzAlgorithm(graph::OptiGraph, partition::Plasmo.Partition; kwargs...)\n\nCreate an algorithm instance by providing a valid Plasmo.Partition.\n\nSchwarzAlgorithm(graph::OptiGraph, partition::Plasmo.Partition; kwargs...)\n\nCreate an algorithm instance and use Metis internally to create partitions.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SubProblemData","page":"API Documentation","title":"PlasmoSchwarz.SubProblemData","text":"SubProblemData{GT<:Plasmo.AbstractOptiGraph}\n\nHolds data specific to a subproblem in the optimization graph.\n\nFields:\n\nrestricted_subgraph::GT: The subgraph representing the \"restricted\" subproblem. This is the subproblem before adding overlap.\nincident_variable_map::OrderedDict{NodeVariableRef,GT}: Maps incident variables to their owning subgraphs.\nincident_constraint_map::OrderedDict{EdgeConstraintRef,GT}: Maps incident constraints to their owning subgraphs.\nprimal_values::OrderedDict{NodeVariableRef,Float64}: Stores the current primal variable values.\ndual_values::OrderedDict{EdgeConstraintRef,Float64}: Stores the current dual variable values.\nprimal_parameters::OrderedDict{NodeVariableRef,NodeVariableRef}: Maps primal variables to their parameter values.\ndual_parameters::OrderedDict{EdgeConstraintRef,NodeVariableRef}: Maps dual variables to their parameter values.\nnode_objectives::OrderedDict{OptiNode,Plasmo.AbstractJuMPScalar}: Objective functions associated with nodes in the subproblem.\nobjective_function::Union{Nothing,Plasmo.AbstractJuMPScalar}: The total objective function for the subproblem, including penalties.\nlast_termination_status::MOI.TerminationStatusCode: The termination status from the last solve.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.Timers","page":"API Documentation","title":"PlasmoSchwarz.Timers","text":"Timers\n\nSimple data structure to track the timing of various stages of the SchwarzAlgorithm.\n\nFields:\n\nstart_time::Float64: Time when the algorithm starts.\ninitialize_time::Float64: Time taken to initialize the algorithm.\neval_objective_time::Float64: Time taken to evaluate the objective function.\neval_primal_feasibility_time::Float64: Time taken to evaluate primal feasibility.\neval_dual_feasibility_time::Float64: Time taken to evaluate dual feasibility.\ncommunicate_time::Float64: Time spent in inter-subproblem communication.\nupdate_subproblem_time::Float64: Time taken to update subproblems.\nsolve_subproblem_time::Float64: Time taken to solve subproblems.\ntotal_time::Float64: Total time for the entire process.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._check_tolerance-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._check_tolerance","text":"_check_tolerance(algorithm::SchwarzAlgorithm) -> Bool\n\nCheck if the primal or dual residuals exceed the specified tolerance. This  determines whether the algorithm should continue iterating.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._extract_constraints-Tuple{Vector{Vector{OptiEdge}}}","page":"API Documentation","title":"PlasmoSchwarz._extract_constraints","text":"_extract_constraints(subgraph_boundary_edges::Vector{Vector{OptiEdge}}) -> Vector{Vector{ConstraintRef}}\n\nRetrieve the constraints associated with boundary edges for a set of subgraphs.  For each subgraph, the constraints tied to its boundary edges are collected.\n\nArgs:\n\nsubgraph_boundary_edges::Vector{Vector{OptiEdge}}: A vector of vectors,  where each inner vector contains the boundary edges of a specific subgraph.\n\nReturns:     A vector of vectors, where each inner vector contains the constraints      associated with the boundary edges of a specific subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._extract_node_objectives-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._extract_node_objectives","text":"_extract_node_objectives(algorithm::SchwarzAlgorithm)\n\nExtracts separable objective terms from the global graph and assigns them to the nodes  of each subproblem's restricted subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._find_boundary_edges-Tuple{OptiGraph, Vector{OptiGraph}}","page":"API Documentation","title":"PlasmoSchwarz._find_boundary_edges","text":"_find_boundary_edges(graph::OptiGraph, subgraphs::Vector{OptiGraph}) -> Vector{Vector{OptiEdge}}\n\nIdentify the boundary edges for a set of subgraphs within a given hypergraph.  Boundary edges are those incident to nodes at the interface between the subgraphs  and the rest of the graph.\n\nArgs:\n\ngraph::OptiGraph: The main graph containing the subgraphs and edges.\nsubgraphs::Vector{OptiGraph}: A vector of subgraphs for which boundary edges  need to be identified.\n\nReturns:     A vector of vectors, where each inner vector contains the boundary edges      associated with a specific subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._formulate_objective_penalty-Tuple{OptiGraph, Float64}","page":"API Documentation","title":"PlasmoSchwarz._formulate_objective_penalty","text":"_formulate_objective_penalty(expanded_subgraph::OptiGraph, mu::Float64)\n\nAdds dual penalties and an augmented Lagrangian penalty term to the objective of the  given subproblem.\n\nArgs:\n\nexpanded_subgraph: The subproblem graph with overlap regions.\nmu: The penalty parameter for the augmented Lagrangian method.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._get_subproblem-Tuple{SchwarzAlgorithm, Union{OptiEdge, OptiNode}}","page":"API Documentation","title":"PlasmoSchwarz._get_subproblem","text":"_get_subproblem(algorithm::SchwarzAlgorithm, element::Plasmo.OptiElement) -> GT\n\nRetrieves the subproblem associated with a given element in the optimization graph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._initialize_subproblem_objectives-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._initialize_subproblem_objectives","text":"_initialize_subproblem_objectives(algorithm::SchwarzAlgorithm)\n\nInitializes the objective functions for each subproblem in the algorithm. \n\nThis function either sets node objectives directly, if specified, or extracts and assigns the graph's separable objective terms to the subproblems. \n\nAdditionally, augmented Lagrangian penalty terms are added to the objectives.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._is_hierarchical-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._is_hierarchical","text":"_is_hierarchical(graph::OptiGraph)\n\nCheck whether the given graph is hierarchical (i.e. contains nodes and subgraphs.)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._retrieve_neighbor_values-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._retrieve_neighbor_values","text":"_retrieve_neighbor_values(subproblem_graph::OptiGraph)\n\nFetches primal and dual values from neighboring subproblems linked via incident variables and constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._solve_subproblem-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._solve_subproblem","text":"_solve_subproblem(subproblem_graph::OptiGraph)\n\nSolves an individual subproblem and logs its termination status.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._update_objective_penalty-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._update_objective_penalty","text":"_update_objective_penalty(expanded_subgraph::OptiGraph)\n\nUpdates the terms in the subproblem's objective based on the current primal and dual values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._update_subproblem-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._update_subproblem","text":"_update_suproblem(subproblem_graph::OptiGraph)\n\nUpdates the objective penalty terms of the given subproblem based on the current neighbor values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_dual_feasibility-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_dual_feasibility","text":"calculate_dual_feasibility(algorithm::SchwarzAlgorithm) -> Vector{Float64}\n\nEvaluate the dual feasibility of the linking constraints defined over the  algorithm's graph. For each linking constraint, the function calculates the  difference between the maximum and minimum dual values across subproblems.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the graph and linking constraints.\n\nReturns:     A vector of dual residuals for the linking constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_objective_value-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_objective_value","text":"calculate_objective_value(algorithm::SchwarzAlgorithm) -> Float64\n\nEvaluate the objective value defined over the algorithm's graph. The function uses  the current variable values from the subproblems to compute the overall objective.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the objective function  and subproblem mappings.\n\nReturns:     The evaluated objective value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_primal_feasibility-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_primal_feasibility","text":"calculate_primal_feasibility(algorithm::SchwarzAlgorithm) -> Vector{Float64}\n\nEvaluate the primal feasibility of the linking constraints defined over the  algorithm's graph. This is done by checking the residuals between the linking  constraints and their expected values based on the subproblem solutions.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the graph and linking constraints.\n\nReturns:     A vector of primal residuals for the linking constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.check_valid_problem-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.check_valid_problem","text":"check_valid_problem(algorithm::SchwarzAlgorithm) -> Bool\n\nValidates the setup of an optimization problem for the specified algorithm. This function performs the following checks:\n\nEnsures a subproblem optimizer is defined in the algorithm options.\nValidates the consistency of subproblem graphs with their respective restricted subgraphs.\nConfirms that the objective function is separable. Non-separable objectives are currently unsupported.\nVerifies that the optimization graph does not exhibit a hierarchical structure, which is unsupported.\n\nIf some of these checks fail, the algorithm's status is set to MOI.INVALID_MODEL, and an appropriate error is thrown.\n\nNotes:\n\nAdditional validations planned for future implementations:\nChecking for non-contiguous partitions.\nEnsuring there is sufficient overlap (at least 1) in expanded graphs.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.do_iteration-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.do_iteration","text":"do_iteration(algorithm::SchwarzAlgorithm)\n\nPerforms a single iteration of the algorithm. This involves:\n\nSolving each subproblem.\nCommunicating primal and dual values between subproblems.\nUpdating subproblem objectives, penalties, and neighbor values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.eval_iteration-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.eval_iteration","text":"eval_iteration(algorithm::SchwarzAlgorithm; save_iteration::Bool=true)\n\nEvaluate the current iterate of the algorithm by calculating primal and dual  feasibility, as well as the objective value. Optionally, the iterate values  can be stored internally for tracking progress.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object representing the current optimization state.\nsave_iteration::Bool: Whether to save the iterate values. Default is true.\n\nReturns:     Nothing. Updates the algorithm state with current feasibility and objective values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.initialize!-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.initialize!","text":"initialize!(algorithm::SchwarzAlgorithm)\n\nInitializes the algorithm by validating the input problem and setting up subproblems. This includes:\n\nValidating the global graph and subproblem consistency.\nAssigning incident constraints and variables.\nSetting up objective penalties for the subproblems.\n\nThrows:\n\nArgumentError if the algorithm fails to initialize.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.reset_iterations-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.reset_iterations","text":"reset_iterations(algorithm::SchwarzAlgorithm)\n\nResets the algorithm's iteration counters and initializes the timers. Also sets up optimizers for each subproblem.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.run_algorithm!-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.run_algorithm!","text":"run_algorithm!(algorithm::SchwarzAlgorithm)\n\nExecute the optimization algorithm, iteratively solving subproblems and updating  the solution until convergence or a stopping criterion is met.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/introduction/#PlasmoSchwarz.jl","page":"Introduction","title":"PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"PlasmoSchwarz.jl is a custom decomposition-based solver that exploits the graph structure defined for a Plasmo.jl OptiGraph and applies an overlapping Schwarz decomposition based on the user-defined structure. The algorithm is outlined in the paper \"A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl\" and in Prof. Sungho Shin's PhD Dissertation, \"Graph-Structured Nonlinear Programming: Properties and Algorithms\". ","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"Schwarz decomposition is an iterative algorithm takes advantage of Plasmo.jl's subgraph structuring capabilities by partitioning an optimization problem into separate subgraphs. The subgraphs can then be expanded to overlap with other subgraphs, and a single iteration of the algorithm solves each subgraph, which can be done in parallel. After optimization, solutions around the overlapping regions are shared between subgraphs and used within the algorithm to help the subgraphs converge to the solution of the overall problem. Schwarz decomposition does not support integer variables. Further, in practice, convergence of PlasmoSchwarz is dependent on problem formulation and the degree of overlap between problems. Convergence is not guaranteed, but primal and dual values can be used to detect whether a local solution has been reached. ","category":"page"},{"location":"PlasmoSchwarz/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/plasmo-dev/PlasmoAlgorithms.jl/tree/main/lib/PlasmoSchwarz.git\"))","category":"page"},{"location":"PlasmoSchwarz/introduction/#Citing-PlasmoSchwarz.jl","page":"Introduction","title":"Citing PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"If you find Plasmo.jl useful for your work, you may cite the manuscript as:","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"@article{Jalving2022,\n  title={A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\n  author={Jordan Jalving and Sungho Shin and Victor M. Zavala},\n  journal={Mathematical Programming Computation},\n  year={2022},\n  volume={14},\n  pages={699 - 747},\n  doi={10.1007/s12532-022-00223-3}\n}","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"You can also access a freely available pre-print.","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"There are also details on this algorithm in Prof. Sungho Shin's PhD dissertation here:","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"@book{shin2021graph,\n  title={Graph-Structured Nonlinear Programming: Properties and Algorithms},\n  author={Shin, Sungho},\n  year={2021},\n  publisher={The University of Wisconsin-Madison}\n}","category":"page"},{"location":"PlasmoSchwarz/introduction/#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"quickstart.md\"\n    \"algorithm.md\"\n    \"api_docs.md\"\n    ]\nDepth = 2","category":"page"}]
}
