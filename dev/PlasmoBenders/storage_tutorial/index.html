<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Storage Operation · PlasmoAlgorithms.jl</title><meta name="title" content="Storage Operation · PlasmoAlgorithms.jl"/><meta property="og:title" content="Storage Operation · PlasmoAlgorithms.jl"/><meta property="twitter:title" content="Storage Operation · PlasmoAlgorithms.jl"/><meta name="description" content="Documentation for PlasmoAlgorithms.jl."/><meta property="og:description" content="Documentation for PlasmoAlgorithms.jl."/><meta property="twitter:description" content="Documentation for PlasmoAlgorithms.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlasmoAlgorithms.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">PlasmoBenders.jl</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../algorithm/">Algorithm</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../solver/">Solver Options</a></li><li><a class="tocitem" href="../graph_structure/">Exploiting Graph Structure</a></li><li><a class="tocitem" href="../api_docs/">API Documentation</a></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox" checked/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Storage Operation</a><ul class="internal"><li><a class="tocitem" href="#Problem-Formulation"><span>Problem Formulation</span></a></li><li><a class="tocitem" href="#Modeling-the-Problem-with-Plasmo"><span>Modeling the Problem with Plasmo</span></a></li><li><a class="tocitem" href="#Solving-with-PlasmoBenders"><span>Solving with PlasmoBenders</span></a></li><li><a class="tocitem" href="#Querying-Solutions"><span>Querying Solutions</span></a></li></ul></li><li><a class="tocitem" href="../sizing_tutorial/">Equipment Sizing</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">PlasmoBenders.jl</a></li><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Storage Operation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Storage Operation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/plasmo-dev/PlasmoAlgorithms.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/plasmo-dev/PlasmoAlgorithms.jl/blob/main/docs/src/PlasmoBenders/storage_tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Storage-Operation"><a class="docs-heading-anchor" href="#Storage-Operation">Storage Operation</a><a id="Storage-Operation-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-Operation" title="Permalink"></a></h1><p>This example is a simple example highlighting how PlasmoBenders can be applied to solve a temporal problem using Nested Benders Decomposition (Dual Dynamic Programming).</p><h2 id="Problem-Formulation"><a class="docs-heading-anchor" href="#Problem-Formulation">Problem Formulation</a><a id="Problem-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Formulation" title="Permalink"></a></h2><p>The example below is a simplified storage operation problem, where a raw material can be purchased and converted to a product and sold. The price of the product is variable, so it is most economical to store the product at times of low price and sell at times of high price. This problem can be considered a &quot;multi-scale&quot; problem because it is making decisions at each time point while having to consider longer-term product prices. The mathematical problem is as follows: </p><p class="math-container">\[\begin{align*}
    \min &amp;\; \sum_{t=1}^T c^{raw}_t u^{raw}_t - c^{sell}_t x^{sell}_t \\
    \textrm{s.t.} &amp;\; x^{store}_{t+1} - x^{store}_t = x^{save}_t, \quad t = 1, ..., T-1\\
    &amp;\; x^{save}_t + x^{sell}_t - \alpha \cdot  u_t^{raw} = 0, \quad t = 1, ..., T \\
    &amp;\; 0 \le x^{store}_t \le \overline{d}^{store}, \quad t = 1, ..., T \\
    &amp;\; 0 \le x^{sell}_t \le \overline{d}^{sell}, \quad t = 1, ..., T \\
    &amp;\; \underline{d}^{save} \le x^{save}_t \le \overline{d}^{save}, \quad t = 1, ..., T \\
    &amp;\; x^{store}_1 = \bar{x}^{store}
\end{align*}\]</p><p>Here, <span>$\underline{d}$</span> and <span>$\overline{d}$</span> are the upper and lower bounds on their respective variables, <span>$x^{store}_t$</span> is the amount of product in storage at time <span>$t$</span>, <span>$x^{save}_t$</span> is the amount of product sent to storage (can be negative), <span>$x^{sell}_t$</span> is the amount of product sold, <span>$u^{raw}_t$</span> is the amount of raw material purchased, <span>$c^{sell}_t$</span> is the price for product at time <span>$t$</span>, <span>$c^{raw}$</span> is the (constant) cost of raw material purchased, and <span>$\alpha$</span> is a conversion factor from raw material to product. The first constraint is a mass balance on the storage, so that <span>$x^{save}_t$</span> represents the change in storage at time <span>$t$</span>. The second constraint is a mass balance on product at time <span>$t$</span>, which ensures that any product generated (<span>$\alpha u^{raw}_t$</span>) must either be sold or sent to storage. </p><h2 id="Modeling-the-Problem-with-Plasmo"><a class="docs-heading-anchor" href="#Modeling-the-Problem-with-Plasmo">Modeling the Problem with Plasmo</a><a id="Modeling-the-Problem-with-Plasmo-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-the-Problem-with-Plasmo" title="Permalink"></a></h2><p>This problem can be modeled as a linear graph using Plasmo. We will represent each time point as a node in the graph, with <span>$T = 20$</span> total nodes.  The code for building this problem is shown below: </p><pre><code class="language-julia hljs">using Plasmo, HiGHS, PlasmoBenders

# Set problem data
N = 20
x_price = fill(5, N); u_cost = fill(20, N)
x_price[6:10] .= 20; x_price[16:20] .= 50

# Define OptiGraph and ndoes
graph = OptiGraph()
@optinode(graph, nodes[1:N])

# Fill each node with variables and constraints
for (j, node) in enumerate(nodes)
    @variable(node, 0 &lt;= x_storage &lt;= 100)
    @variable(node, 0 &lt;= x_sell &lt;= 50)
    @variable(node, -20 &lt;= x_save &lt;= 20)
    @variable(node, 0 &lt;= u &lt;= 25)

    @constraint(node, x_save + x_sell - 2 * u == 0)
    @objective(node, Min, -x_sell * x_price[j] + u * u_cost[j])
end

# Set initial storage value
@constraint(nodes[1], nodes[1][:x_storage] == 10)

# Define linking constraints for storage
@linkconstraint(graph, [i = 1:(N - 1)], nodes[i + 1][:x_storage] - nodes[i][:x_storage] == nodes[i][:x_save])</code></pre><p>The above problem results in the following shape: </p><p><img src="../../figures/20node_graph.png" alt="20node graph"/></p><p>This problem is a simple LP and could be solved directly with a LP solver. However, we will solve this problem using Nested Benders Decomposition to highlight how the decomposition scheme works. We will partition this problem into four subproblems, each with five nodes. This can be done with the code below:</p><pre><code class="language-julia hljs">node_membership_vector = zeros(Int, N)
node_membership_vector[1:5]   .= 1
node_membership_vector[6:10]  .= 2
node_membership_vector[11:15] .= 3
node_membership_vector[16:20] .= 4

partition = Plasmo.Partition(graph, node_membership_vector)

apply_partition!(graph, partition)

for subgraph in local_subgraphs(graph)
    set_to_node_objectives(subgraph)
end</code></pre><p>The resulting problem can be visualized as: </p><p><img src="../../figures/20node_graph_partitioned.png" alt="20node partitioned graph"/></p><h2 id="Solving-with-PlasmoBenders"><a class="docs-heading-anchor" href="#Solving-with-PlasmoBenders">Solving with PlasmoBenders</a><a id="Solving-with-PlasmoBenders-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-with-PlasmoBenders" title="Permalink"></a></h2><p>The subgraphs have a (linear) tree structure, so we can pass this graph to PlasmoBenders&#39; <code>BendersAlgorithm</code> constructor and solve it with Nested Benders Decomposition. This also requires setting a &quot;root subgraph.&quot; We will set the first subgraph as the root subgraph, but any of the subgraphs could be used. </p><pre><code class="language-julia hljs">solver = optimizer_with_attributes(HiGHS.Optimizer, &quot;output_flag&quot; =&gt; false)

root_graph = local_subgraphs(graph)[1]
BendersAlgorithm(graph, root_graph, solver = solver)</code></pre><p>The Nested Benders scheme is able to reach the optimal solution after 5 iterations. The bounds and gap are shown below.</p><p><img src="../../figures/storage_example_plot.png" alt="NBD_operation"/></p><p>Note that the first iteration returns an upper bound that is well above the optimal. The first iteration of the solve is performing a &quot;receding-horizon&quot; approach, where each subgraph is solved in series and the optimal solution passed to the next subgraph. This results in a sub optimal solution since each problem is not &quot;seeing&quot; the future prices of the product. The cutting planes that are formed after each iteration essentially help provide the previous subgraphs with knowledge of how their solution impacts the solution of future subproblems, which results in the upper bound eventually converging to the true solution. </p><h2 id="Querying-Solutions"><a class="docs-heading-anchor" href="#Querying-Solutions">Querying Solutions</a><a id="Querying-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-Solutions" title="Permalink"></a></h2><p>PlasmoBenders provides access to API functions for querying the optimal solution from the BendersAlgorithm object. We can query the solution by calling </p><pre><code class="language-julia hljs">JuMP.objective_value(benders_opt)</code></pre><p>which returns the best upper bound. We can query the lower bound by calling</p><pre><code class="language-julia hljs">JuMP.dual_objective_value(benders_opt)</code></pre><p>This lower bound can be less than the upper bound for MIP problems since there can be a duality gap. We can also query the relative gap by calling</p><pre><code class="language-julia hljs">relative_gap(benders_opt)</code></pre><p>Individual variable values can be retrieved by calling</p><pre><code class="language-julia hljs">JuMP.value(benders_opt, graph[:nodes][1][:x_sell])</code></pre><p>In addition, <code>JuMP.value</code> has been extended to also take a vector of variables rather than just a single variable, so we can also call</p><pre><code class="language-julia hljs">JuMP.value(benders_opt, all_variables(graph))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_docs/">« API Documentation</a><a class="docs-footer-nextpage" href="../sizing_tutorial/">Equipment Sizing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 25 January 2025 23:31">Saturday 25 January 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
