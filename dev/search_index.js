var documenterSearchIndex = {"docs":
[{"location":"PlasmoBenders/storage_tutorial/#Storage-Operation","page":"Storage Operation","title":"Storage Operation","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This example is a simple example highlighting how PlasmoBenders can be applied to solve a temporal problem using Nested Benders Decomposition (Dual Dynamic Programming).","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Problem-Formulation","page":"Storage Operation","title":"Problem Formulation","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The example below is a simplified storage operation problem, where a raw material can be purchased and converted to a product and sold. The price of the product is variable, so it is most economical to store the product at times of low price and sell at times of high price. This problem can be considered a \"multi-scale\" problem because it is making decisions at each time point while having to consider longer-term product prices. The mathematical problem is as follows: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"beginalign*\n    min  sum_t=1^T c^raw_t u^raw_t - c^sell_t x^sell_t \n    textrmst  x^store_t+1 - x^store_t = x^save_t quad t = 1  T-1\n     x^save_t + x^sell_t - alpha cdot  u_t^raw = 0 quad t = 1  T \n     0 le x^store_t le overlined^store quad t = 1  T \n     0 le x^sell_t le overlined^sell quad t = 1  T \n     underlined^save le x^save_t le overlined^save quad t = 1  T \n     x^store_1 = barx^store\nendalign*","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Here, underlined and overlined are the upper and lower bounds on their respective variables, x^store_t is the amount of product in storage at time t, x^save_t is the amount of product sent to storage (can be negative), x^sell_t is the amount of product sold, u^raw_t is the amount of raw material purchased, c^sell_t is the price for product at time t, c^raw is the (constant) cost of raw material purchased, and alpha is a conversion factor from raw material to product. The first constraint is a mass balance on the storage, so that x^save_t represents the change in storage at time t. The second constraint is a mass balance on product at time t, which ensures that any product generated (alpha u^raw_t) must either be sold or sent to storage. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Modeling-the-Problem-with-Plasmo","page":"Storage Operation","title":"Modeling the Problem with Plasmo","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This problem can be modeled as a linear graph using Plasmo. We will represent each time point as a node in the graph, with T = 20 total nodes.  The code for building this problem is shown below: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Set problem data\nN = 20\nx_price = fill(5, N); u_cost = fill(20, N)\nx_price[6:10] .= 20; x_price[16:20] .= 50\n\n# Define OptiGraph and ndoes\ngraph = OptiGraph()\n@optinode(graph, nodes[1:N])\n\n# Fill each node with variables and constraints\nfor (j, node) in enumerate(nodes)\n    @variable(node, 0 <= x_storage <= 100)\n    @variable(node, 0 <= x_sell <= 50)\n    @variable(node, -20 <= x_save <= 20)\n    @variable(node, 0 <= u <= 25)\n\n    @constraint(node, x_save + x_sell - 2 * u == 0)\n    @objective(node, Min, -x_sell * x_price[j] + u * u_cost[j])\nend\n\n# Set initial storage value\n@constraint(nodes[1], nodes[1][:x_storage] == 10)\n\n# Define linking constraints for storage\n@linkconstraint(graph, [i = 1:(N - 1)], nodes[i + 1][:x_storage] - nodes[i][:x_storage] == nodes[i][:x_save])","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The above problem results in the following shape: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: 20node graph)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This problem is a simple LP and could be solved directly with a LP solver. However, we will solve this problem using Nested Benders Decomposition to highlight how the decomposition scheme works. We will partition this problem into four subproblems, each with five nodes. This can be done with the code below:","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"node_membership_vector = zeros(Int, N)\nnode_membership_vector[1:5]   .= 1\nnode_membership_vector[6:10]  .= 2\nnode_membership_vector[11:15] .= 3\nnode_membership_vector[16:20] .= 4\n\npartition = Plasmo.Partition(graph, node_membership_vector)\n\napply_partition!(graph, partition)\n\nfor subgraph in getsubgraphs(graph)\n    set_to_node_objectives(subgraph)\nend","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The resulting problem can be visualized as: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: 20node partitioned graph)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Solving-with-PlasmoBenders","page":"Storage Operation","title":"Solving with PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The subgraphs have a (linear) tree structure, so we can pass this graph to PlasmoBenders' BendersOptimizer constructor and solve it with Nested Benders Decomposition. This also requires setting a \"root subgraph.\" We will set the first subgraph as the root subgraph, but any of the subgraphs could be used. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\n\nroot_graph = getsubgraphs(graph)[1]\nBendersOptimizer(graph, root_graph, solver = solver)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The Nested Benders scheme is able to reach the optimal solution after 5 iterations. The bounds and gap are shown below.","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: NBD_operation)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Note that the first iteration returns an upper bound that is well above the optimal. The first iteration of the solve is performing a \"receding-horizon\" approach, where each subgraph is solved in series and the optimal solution passed to the next subgraph. This results in a sub optimal solution since each problem is not \"seeing\" the future prices of the product. The cutting planes that are formed after each iteration essentially help provide the previous subgraphs with knowledge of how their solution impacts the solution of future subproblems, which results in the upper bound eventually converging to the true solution. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Querying-Solutions","page":"Storage Operation","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"PlasmoBenders provides access to API functions for querying the optimal solution from the BendersOptimizer object. We can query the solution by calling ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.objective_value(benders_opt)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"which returns the best upper bound. We can query the lower bound by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.dual_objective_value(benders_opt)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This lower bound can be less than the upper bound for MIP problems since there can be a duality gap. We can also query the relative gap by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"relative_gap(benders_opt)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Individual variable values can be retrieved by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.value(benders_opt, graph[:nodes][1][:x_sell])","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"In addition, JuMP.value has been extended to also take a vector of variables rather than just a single variable, so we can also call","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.value(benders_opt, all_variables(graph))","category":"page"},{"location":"PlasmoBenders/introduction/#PlasmoBenders.jl","page":"Introduction","title":"PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"PlasmoBenders.jl is a custom decomposition-based solver that exploits the graph structure defined for a Plasmo.jl OptiGraph and applies Benders or Nested Benders Decomposition based on the user-defined structure (i.e., it detects the copmlicating variables based on the graph structure). In this way, PlamsoBenders implements these decomposition approaches automatically for the user. ","category":"page"},{"location":"PlasmoBenders/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"PlasmoBenders\")","category":"page"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"or alternatively from the Julia package manager by performing the following:","category":"page"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"pkg> add PlasmoBenders","category":"page"},{"location":"PlasmoBenders/introduction/#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"algorithm.md\"\n    \"quickstart.md\"\n    \"solver.md\"\n    \"graph_structure.md\"\n    \"api_docs.md\"\n    \"storage_tutorial.md\"\n    ]\nDepth = 2","category":"page"},{"location":"PlasmoBenders/api_docs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"PlasmoBenders/api_docs/#API-Manual","page":"API Documentation","title":"API Manual","text":"","category":"section"},{"location":"PlasmoBenders/api_docs/","page":"API Documentation","title":"API Documentation","text":"Modules = [PlasmoBenders]","category":"page"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.AbstractPBAlgorithm","page":"API Documentation","title":"PlasmoBenders.AbstractPBAlgorithm","text":"AbstractPBAlgorithm{T}\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersAlgorithm","page":"API Documentation","title":"PlasmoBenders.BendersAlgorithm","text":"BendersAlgorithm\n\nOptimizer object for dual dynamic programming with graphs. Currently only implemented for linear tree structures.\n\nAttributes include the following (where noted as dictionaries, these are mappings from the DDP subproblems to the data described)\n\ngraph - Plasmo OptiGraph for appplying DDP\nroot_object - node or subgraph in graph indicating where to start the DDP algorithm\nis_MIP = Boolean indicating if the problem is a MIP or not\nsolve_order - vector of OptiNodes in the order that they are solved by DDP\nsolve_order_dict - dictionary mapping to a vector of all the \"next objects\" for a given object\nparent_objects - dictionary mapping to the previous subproblem\nmax_iters - maximum number of DDP iterations\ntol - (absolute) termination tolerance between upper and lower bounds\ncurrent_iter - current iteration of DDP algorithm\nM - lower bound for the cost-to-go function at each iteration\ndual_iters - dictionary mapping optinodes to the corresponding dual values  at each iteration; dual values come from solution of following node\nprimal_iters - dictionary mapping optinodes to the primal solutions of the  complicating variables on the given node\nphis - dictionary mapping optinodes to the objective of the immediately following node\nphis_LR - dictionary mapping optinodes to the objective of the lagrangean (used for strenghtened cuts)  relaxation of the following node; used for strengthened Benders cuts in MIPs\ntime_forward_pass - time spent in the forward pass (seconds)\ntime_backward_pass - time spent in the backward pass (seconds)\ntime_init - time initializing the optimizer (seconds)\ntime_iterations - vector of the times spent in each Iteration\ncomp_vars - dictionary mapping the node to a vector of its complicating variables\ncomp_var_map - dictionary mapping the node to a dictionary of complicating variables  mapped to their index in comp_vars\nvar_copy_map - dictionary mapping the node to a dictionary mapping the complicating  variables to their copies on the following node\nobjective_value - the final objective value (from upper bound)\nlower_bounds - vector of lower bounds at each iteration\nupper_bounds - vector of upper bounds at each iteration\nregularize_data - regularization data object\nbinary_map - dictionary mapping the nodes to a vector of binary variables on the node\ninteger_map - dictionary mapping the nodes to a vector of integer variables on the node\nlast_solutions - dictionary mapping the nodes to a vector of the last solutions\nvar_solution_map - dictionary mapping the variables to their index on the last_solutions vector\nvar_to_graph_map - dictionary mapping the variables to their owning subproblem subgraph\noptions - solver options for DDP algorithm\next - Dictionary for extending certain procedures\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersAlgorithm-Union{Tuple{T}, Tuple{OptiGraph, T}} where T<:OptiNode","page":"API Documentation","title":"PlasmoBenders.BendersAlgorithm","text":"BendersAlgorithm(graph, root_object; kwargs...)\n\nFunction for creating the BendersAlgorithm object from graph. root_object must be an OptiNode or subgraph on graph. key ward arguments include the following\n\nmax_iters = 100 - maximum number of iterations\ntol = 1e-7 - termination tolerance between upper and lower bounds\nM = 0 - lower bound on cost-to-go estimator for each node\nis_MIP = nothing - indicates if the problem is a MIP. If it is passed as nothing,  PlasmoBenders will check to see if it is a MIP, and will set is_MIP accordingly\nsolver = nothing - if defined, this solver will be set for all subproblems\nstrengthened = false - whether to use strengthened Benders cuts (see https://doi.org/10.1007/s10107-018-1249-5.)\nmulticut = true - whether to use multicuts (rather than aggregated cuts) when applicable\nregularize = false - whether to regularize solution of next iterates\nparallelize_benders = false - whether to parallelize subproblem solution when the problem has a Benders-type structure defined\nparallelize_forward = false - whether to parallelize forward pass if possible; not yet supported\nparallelize_backward = false - whether to parallelize backward pass\nadd_slacks::Bool = false - whether to add slack variables to the linking constraints to  help ensure feasibility between solutions; slack variables are penalized in objective\nfix_slacks = false - whether to fix the slack variables to zero they only relax if a problem is infeasible\nwarm_start::Bool = true - whether to set the previous iterations solutions as the  starting values for the next iterations forward pass\nrelaxed_init_cuts = false - whether to generate initial cuts by relaxing the problem and solving the whole problem; only applies for MILPs\nslack_penalty = 1e6 - coefficient on slack variables in objective\nregularize_param = 0.5 - regularization parameter; must be between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersOptions","page":"API Documentation","title":"PlasmoBenders.BendersOptions","text":"BendersOptions\n\nOptions object for dual dynamic programming with graphs\n\nAttributes include\n\nstrengthened::Bool - whether to use strengthened cuts\nmulticut::Bool - whether the problem should use aggregated or multiple cuts when there are multiple objects generating information in the forward pass\nregularize::Bool - whether to used regularization for getting next cuts\nparallelize_benders::Bool - whether to parallelize Benders problems if applicable\nparallelize_forward::Bool - whether to parallelize the forward pass if possible\nparallelize_backward::Bool - whether to parallelize the backward pass if possible\nadd_slacks::Bool - whether to add slack variables to linking constraints\nfix_slacks::Bool - whether to fix the slack variables to zero; slacks will be relaxe if the problem is infeasible\nwarm_start::Bool - whether to warm start the problem using the previous best solution\nrelaxed_init_cuts::Bool - whether to create some initial cuts by relaxing the problem and solving the full problem as an LP; only applies if the problem is a MIP\nslack_penalty::Real - penalty for nonzero slacks; only applies for add_slacks = true\nregularize_param::Real - parameter for regularization; essentially how far from optimal the solution can end up being for choosing the next iterates.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.RegularizeData","page":"API Documentation","title":"PlasmoBenders.RegularizeData","text":"RegularizeData\n\nData structure for storing regularization data\n\nAll attributes include a dictionary which is indexed by the subproblem objects of DDP\n\nobjective_function - the objective function of an object\nubs - value of the object's objective (without theta)\nlbs - value of the object's objective (with theta)\nbest_ub - best upper bound\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#JuMP.value-Tuple{BendersAlgorithm, NodeVariableRef}","page":"API Documentation","title":"JuMP.value","text":"JuMP.value(opt::BendersAlgorithm, var::NodeVariableRef)\n\nReturns the value of var from the BendersAlgorithm object. The value corresponds to the best upper bound of the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#JuMP.value-Tuple{BendersAlgorithm, Vector{NodeVariableRef}}","page":"API Documentation","title":"JuMP.value","text":"JuMP.value(opt::BendersAlgorithm, vars::Vector{NodeVariableRef})\n\nReturns a vector of variables contained in the vars vector from the BendersAlgorithm object. The values correspond to the best upper bound of the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_Benders_cuts!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._add_Benders_cuts!","text":"_add_Benders_cuts!(optimizer::BendersAlgorithm)\n\nAdd Benders cuts to each nested problem; uses results from the backward pass and forward pass to create cuts.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_initial_relaxed_cuts!-Union{Tuple{BendersAlgorithm{T}}, Tuple{T}} where T<:Union{OptiGraph, OptiNode}","page":"API Documentation","title":"PlasmoBenders._add_initial_relaxed_cuts!","text":"_add_initial_relaxed_cuts!(optimizer::BendersAlgorithm)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_strengthened_cuts!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._add_strengthened_cuts!","text":"_add_strengthened_cuts!(optimizer::BendersAlgorithm)\n\nAdd strengthened Benders cuts to each nested problem; Follows the process described by Zou et al., 2019 (https://doi.org/10.1007/s10107-018-1249-5) where the cuts come from a Lagrangian relaxation where the lagrange multipliers are the dual variables of the backward pass.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._backward_pass!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._backward_pass!","text":"_backward_pass!(optimizer::BendersAlgorithm)\n\nPerform backward pass for a MIP problem. Backward pass can be done in parallel. Binary and integer variables are relaxed and the problem is solved to get the dual and objective values for producing Benders cuts. If strengthened = true, the stengthened cuts are ALSO added using the approach of Zou et al. https://doi.org/10.1007/s10107-018-1249-5.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._forward_pass!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._forward_pass!","text":"_forward_pass!(optimizer::BendersAlgorithm)\n\nRuns the forward pass for DDP. Follows the node order in solve_order attribute. Save the primal information for complicating variables on each node. If it is not a MIP, also saves the dual and objective value information and adds the Benders cut. Returns the upper and lower bounds, where lower bound is only valid if the problem is not a MIP (otherwise the lower bound comes from the backward pass)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_add_slacks-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_add_slacks","text":"get_add_slacks(optimizer::BendersAlgorithm)\n\nReturn the value of add_slacks from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_fix_slacks-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_fix_slacks","text":"get_fix_slacks(optimizer::BendersAlgorithm)\n\nReturn the value of fix_slacks from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_multicut-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_multicut","text":"get_multicut(optimizer::BendersAlgorithm)\n\nReturn the value of multicut from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_backward-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_backward","text":"get_parallelize_backward(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_backward from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_benders-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_benders","text":"get_parallelize_benders(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_benders from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_forward-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_forward","text":"get_parallelize_forward(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_forward from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize","text":"get_regularize(optimizer::BendersAlgorithm)\n\nReturn the value of regularize from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_best_ub-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_best_ub","text":"get_regularize_best_ub(optimizer::BendersAlgorithm)\n\nReturn the value of bestub from the `regularizedatafield of theBendersAlgorithm`\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_constraint-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_constraint","text":"get_regularize_constraint(optimizer::BendersAlgorithm)\n\nReturn the value of constraint from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_lbs-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_lbs","text":"get_regularize_lbs(optimizer::BendersAlgorithm)\n\nReturn the value of lbs from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_objective_function-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_objective_function","text":"get_regularize_objective_function(optimizer::BendersAlgorithm)\n\nReturn the value of objectivefunction from the `regularizedatafield of theBendersAlgorithm`\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_param-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_param","text":"get_regularize_param(optimizer::BendersAlgorithm)\n\nReturn the value of regularize_param from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_slack-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_slack","text":"get_regularize_slack(optimizer::BendersAlgorithm)\n\nReturn the value of slack from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_ubs-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_ubs","text":"get_regularize_ubs(optimizer::BendersAlgorithm)\n\nReturn the value of ubs from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_relaxed_init_cuts-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_relaxed_init_cuts","text":"get_relaxed_init_cuts(optimizer::BendersAlgorithm)\n\nReturn the value of relaxedinitcuts from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_slack_penalty-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_slack_penalty","text":"get_slack_penalty(optimizer::BendersAlgorithm)\n\nReturn the value of slack_penalty from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_strengthened-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_strengthened","text":"get_strengthened(optimizer::BendersAlgorithm)\n\nReturn the value of strengthened from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_warm_start-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_warm_start","text":"get_warm_start(optimizer::BendersAlgorithm)\n\nReturn the value of warm_start from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.run_algorithm!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.run_algorithm!","text":"run_algorithm!(optimizer::PB.BendersAlgorithm; output::Bool = true, run_gc::Bool = false)\n\nOptimize the graph in BendersAlgorithm by using the DDP algorithm. Keyword argument output indicates whether to print the upper/lower bounds and gap and each iteraiton. run_gc indicates whether to run the garbage collector after each iteraiton. \n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_add_slacks!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_add_slacks!","text":"set_add_slacks!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of add_slacks from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_fix_slacks!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_fix_slacks!","text":"set_fix_slacks!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of fix_slacks from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_multicut!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_multicut!","text":"set_multicut!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of multicut from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_backward!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_backward!","text":"set_parallelize_backward!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_backward from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_benders!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_benders!","text":"set_parallelize_benders!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_benders from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_forward!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_forward!","text":"set_parallelize_forward!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_forward from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_regularize!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_regularize!","text":"set_regularize!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of regularize from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_regularize_param!-Tuple{BendersAlgorithm, Real}","page":"API Documentation","title":"PlasmoBenders.set_regularize_param!","text":"set_regularize_param!(optimizer::BendersAlgorithm, val::Real)\n\nSet the value of regularize_param from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_relaxed_init_cuts!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_relaxed_init_cuts!","text":"set_relaxed_init_cuts!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of relaxedinitcuts from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_slack_penalty!-Tuple{BendersAlgorithm, Real}","page":"API Documentation","title":"PlasmoBenders.set_slack_penalty!","text":"set_slack_penalty!(optimizer::BendersAlgorithm, val::Real)\n\nSet the value of slack_penalty from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_strengthened!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_strengthened!","text":"set_strengthened!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of strengthened from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_warm_start!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_warm_start!","text":"set_warm_start!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of warm_start from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/solver/#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"PlasmoBenders supports several different solver options. These are keyword arguments that can be  These include the following: ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"strengthened::Bool - whether to use \"strengthened\" Benders cuts for MILP problems. These cuts are outlined here and here. They add some computational time to the algorithm but can result in tighter cuts (and thus fewer iterations or a smaller duality gap) being added to the subproblems. This only applies if there are integer variables in the subproblems (not just the root subgraph). Currently, these only work for MILP problems, not for LP problems.\nmulticut::Bool - Whether to use multi-cuts (instead of aggregated cuts). When a subproblem has multiple children subgraphs (i.e., is connected to multiple subproblems in the next stage), you can use either an aggregated cut (where there is a single cost-to-go variable) or multi-cuts, where each child subproblem has its own corresponding cost-to-go function. Multi-cuts result in more cutting planes being added at each iteration, but aggregated cuts result in fewer overall constraints being added. \nregularize::Bool - Whether to use a regularization scheme to choose the solutions passed to the next stage. PlasmoBenders implements the regularization scheme from here. The regularization only works for Benders Decomposition (BD; i.e., 2-stage problems). This scheme chooses points that are normally interior, feasible points in the master problem. Does not work with warm_start=true.\nregularize_param::Real - A parameter between 0 and 1 that influences how far inside the feasible region the regularization can choose a solution.\nparallelize_benders::Bool - For BD, whether to parallelize the solution of the second stage subgraphs if multiple subgraphs exist.\nparallelize_forward::Bool - Not currently supported. We hope to implement this functionality in the future\nparallelize_backward::Bool - Whether to parallelize the backwards pass.\nadd_slacks::Bool - Whether to add slack variables to the linking constraint that is enforced on the downstream problem. This helps ensure recourse to the subproblems.\nslack_penalty::Real - THe value of the penalty term used on the slack variables added to the linking constraints. \nfix_slacks::Bool - An experimental option where slack variables are fixed until a problem is infeasible, in which case, the slack variables are allowed to be unfixed to make the problem feasible. THere are no convergence guarantees on this approach.\nwarm_start::Bool - Whether to warm start the problems with the best solution that the solver has found so far. Cannot be true if regularize=true. \nrelaxed_init_cuts::Bool - Whether to add initial cuts from a full problem relaxation. For MILP problems, initial cuts can be added by relaxing all integer variables and solving the full problem, and using the resulting primal/dual information to form cutting planes. See Lara.\nmax_iters::Int - The maximum number of iterations to use before termination.\ntol::Real - The relative tolerance between the upper and lower bounds to reach before termination. \nsolver - The subproblem solver to use. If this is not set, it will assume that the user has set a solver on all subgraphs. \nM::Real - Lower bound on all cost-to-go variables. Default value is 0. At the first iteration of the BD and Nested Benders Decomposition, theta is otherwise unconstrained, so this value ensures that the cost-to-variable is bounded. \nis_MIP::Bool - Whether the problem includes mixed integer variables in the subproblems. If the user does not set this value, the BendersOptimizer constructor will detect this value by testing all subgraphs that are not the root subgraph (note that the root subgraph can have mixed integer variables and still set is_MIP to false). This argument determines when the backward pass occurs. For LPs, the backward pass can occur at the same time as the forward pass, but for MILPs, the backward pass is performed separately (and can be parallelized). ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"note: Note\nIf the objective value of a subproblem can be negative, it is important to set M to be less than zero. Otherwise, you can get lower bounds that are greater than upper bounds and the algorithm will not work. ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"The JuMP.optimize! function has been extended to solve a BendersOptimizer object. There are two additional keyword arguments you can set with JuMP.optimize!","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"output::Bool - Whether to output the upper and lower bounds and the gap at each iteration of the algorithm\nrun_gc::Bool - Whether to run the garbage collector at the end of each iteration. Could potentially help with some memory issues. ","category":"page"},{"location":"PlasmoBenders/solver/#Reporting-Issues","page":"Solver Options","title":"Reporting Issues","text":"","category":"section"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"If you encounter issues with PlasmoBenders, please open issues on Github's issue tracker. ","category":"page"},{"location":"PlasmoBenders/algorithm/#Solution-Algorithm-for-PlasmoBenders.jl","page":"Algorithm","title":"Solution Algorithm for PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Benders and Nested Benders Decomposition are iterative algorithms, often used for solving large-scal problems. These algorithms are typically applied to linear programs (LP) and mixed-integer linear programs (MILP). They operate by iteratively solving smaller subproblems and sharing information between these subproblems (typically primal and dual) until an upper and lower bound converge or a different termination criteria is reached. A review of Benders decomposition and its applications can be found here, and an example of Nested Benders Decomposition (also referred to as Dual-Dynamic Programming) can be found here. This documentation will give an overview of the algorithms, but a full discussion of the algorithms can be found in the preprint on this package available here.","category":"page"},{"location":"PlasmoBenders/algorithm/#Benders-Decomposition","page":"Algorithm","title":"Benders Decomposition","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Benders Decomposition (BD) involves decomposing an optimization problem into a master problem and a subproblem(s) and solving these iteratively. The master problem contains a set of complicating variables that, when set, often makes the subproblem(s) easier to solve. The general approach of Benders is to solve the master problem and then to pass the solutions of the master problem to the subproblem(s) and to fix the solution of these variables in the subproblem(s). The subproblem(s) is then solved and information (often dual solutions) from the subproblem(s) is passed back to the master problem and is used to form \"cuts\" or \"cutting planes\" on the master problem. These cuts restrict the feasible region of the master problem, and the process is repeated after the cuts are added.","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"BD is applied to problems of the form ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_1^top x_1 + c_2^top x_2 \n    textrmst  A_1 x_1 + A_2 x_2 le b\n     C_1 x_1 le d_1 \n     C_2 x_2 le d_2\nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, the first constraint prevents us from separating this problem into two subproblems. We can solve this problem with BD by creating a master problem and a subproblem. The master problem has the form","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_1^top x_1 + theta \n    textrmst  C_1 x_1 le d_1 \n     theta ge textrmcuts \nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"where theta is the \"cost-to_go\" variable, which is an underestimate of the optimal value of the subproblem's optimal solution. The variable theta is constrained by cuts that are generated at each iteration of the BD algorithm. The subproblem has the form ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_2^top x_2\n    textrmst  C_2 x_2 le d_2 \n     A_1 z + A_2 x_2 le b \n     z = barx_2 quad (lambda)\nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"where barx is the solution of the master problem at the last iteration and lambda is the dual variable for the corresponding constraint. Note that the constraint A_1z + A_2x_2 le b is enforced at the subproblem level, which ensures that the solution fo the master problem and subproblem is a feasible solution of the original problem (assuming complete recourse). Since theta is an underestimate of the optimal value of the subproblem, solving the master problem produces a lower bound on the original problem's solution. Each iteration of the algorithm (assuming complete recourse) results in a feasible solution to the original problem which forms an upper bound on the original optimization problem.","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"A visualization of BD for graphs is shown below. Here, the graph on the left has two subgraphs with an edge between them. One of the subgraphs can be treated as the \"master\" problem, and the other as the \"subproblem.\" The cost-to-go variable is added to the master problem along with the cutting plane restrictions. The solutions of the master problem are then fixed in the subproblem. These problems are iteratively solved until a solution is reached. ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: BD)","category":"page"},{"location":"PlasmoBenders/algorithm/#Nested-Benders-Decomposition","page":"Algorithm","title":"Nested Benders Decomposition","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Nested Benders Decomposition (NBD) is similar to BD but includes more than two \"stages\" of problems. BD can be considered a \"two-stage\" problem where the master problem is the first stage, which is then linked to a subproblem in a \"second\" stage. In NBD, There can be additional subproblems, such that the subproblem in stage two can contain complicating variables for an additional subproblem in a third stage, and so forth. This can be visualized as shown below. ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: NBD)","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"In NBD, there is a \"forward-pass\" where each stage is solved sequentially and primal solutions are shared to and fixed in the next stage. After each stage has been solved, information can be shared to the previous stage in a \"backward-pass\" to form cutting planes on each previous stage. ","category":"page"},{"location":"PlasmoBenders/algorithm/#Implementation-in-PlasmoBenders.jl","page":"Algorithm","title":"Implementation in PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"PlasmoBenders.jl implements the NBD algorithm. BD can be considered a specialized case of NBD, such that we only need to implement a single algorithm in the code. There are many additional parameters and techniques that NBD can include, and these are covered in other pages of the documentation. ","category":"page"},{"location":"PlasmoBenders/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart gives a brief overview of the functions needed for using PlasmoBenders to solve optimization problems defined in Plasmo. The example below will include a simple graph with three subproblems that we can solve with either Benders Decomposition (BD) or Nested Benders Decomposition (NBD). We will define the problem and then show how to create and solve the BendersOptimizer object.","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Once PlasmoBenders has been installed, you can use it from a Julia session using ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using PlasmoBenders","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoBenders also requires defining a graph with Plasmo, and we will need a solver for the subproblems. We will use HiGHS. These packages will also need to be loaded","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using Plasmo, HiGHS","category":"page"},{"location":"PlasmoBenders/quickstart/#Required-Structure","page":"Quickstart","title":"Required Structure","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"BD and NBD can exploit problem structure, and they require a specific graph structure in order to be applied. PlasmoBenders uses subgraphs as the subproblems, and the subgraphs must form a tree structure. This means that there are no cycles among the subgraphs. In other words, if you start at any subgraph i and move along the edges of the graph to any other subgraph j, you cannot return to subgraph i without traversing the same subgraphs as you did to reach subgraph j. PlasmoBenders, in constructing the BendersOptimizer object, will check structure and error out if the structure is not correct.","category":"page"},{"location":"PlasmoBenders/quickstart/#Basic-OptiGraph","page":"Quickstart","title":"Basic OptiGraph","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"First, we will define a simple graph with 3 subgraphs. Each subgraph will serve as a subproblem of BD/NBD, and each will contain one node. The code below creates this initial graph. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Define optigraphs\ng = OptiGraph(); g1 = OptiGraph()\ng2 = OptiGraph(); g3 = OptiGraph()\n\n# Define problem on first OptiGraph\n@optinode(g1, n)\n@variable(n, x[1:2] >= 0)\n@constraint(n, 2 * x[1] + x[2] == 3)\n@objective(n, Min, x[1] + 2 * x[2])\n\n# Define problem on second OptiGraph\n@optinode(g2, n)\n@variable(n, x >= 0)\n@objective(n, Min, 4 * x)\n\n# Define problem on third OptiGraph\n@optinode(g3, n)\n@variable(n, x >= 1)\n@objective(n, Min, x)\n\n# Add these OptiGraphs as subgraphs to the overall OptiGraph, g\nadd_subgraph!(g, g1); add_subgraph!(g, g2); add_subgraph!(g, g3)\n\n# Set subgraph objectives to be their node's objectives\nset_to_node_objectives(g1)\nset_to_node_objectives(g2)\nset_to_node_objectives(g3)\n\n# Create links between the subgraphs\n@linkconstraint(g0, g1[:n][:x][2] + g2[:n][:x] == 3)\n@linkconstraint(g0, g1[:n][:x][1] + g3[:n][:x] >= 1)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, subgraph 1 is connected to subgraphs 2 and 3 by the link constraints. Subgraphs 2 and 3 are not connected to each other","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nPlasmoBenders currently only works with the Min objective sense for subgraphs. If your subgraphs have Maximizations for objectives, it is recommended that you reformulate your objective so that max f(x) becomes min -f(x).","category":"page"},{"location":"PlasmoBenders/quickstart/#BendersOptimizer-Object","page":"Quickstart","title":"BendersOptimizer Object","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"The BendersOptimizer object updates the subgraphs to have the required cost-to-go variables and variable copies (fixed from previous stages). The constructor requires two arguments: 1) the overall graph and 2) the subgraph that will serve as the \"root\" subgraph. The root subgraph is the \"master\" problem for BD or the first stage problem for NBD. The BendersOptimizer constructor also supports several other key word arguments that are oulined in a separate page of the documentation. These include things like the maximum number of iterations, the convergence tolerance, or whether to use certain other options (e.g., regularization) within the solver. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Before creating the BendersOptimizer object, we note that each subgraph requires a solver set on it. We will use HiGHS below, and we will set the output flag solver option to be false (this reduces the overall output and makes the BendersOptimizer output more readable). We can either set the solver manually, or we can pass the solver to the BendersOptimizer function using the keyward solver. To set the solver manually, we do","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nset_optimizer(g1, solver)\nset_optimizer(g2, solver)\nset_optimizer(g3, solver)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"We can now call the BendersOptimizer function (and if we have not set the solver, we can do so when calling this function).","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nbenders_opt = BendersOptimizer(g, g1, solver = solver)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, benders_opt is the optimizer object. It includes several attributes, including the upper and lower bounds at each iteration, solver options, a mapping of complicating variables to their subproblems, and dual and primal information from each iteration. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Because PlasmoBenders requires a tree structure, we can actually set any subgraph as the root graph. Setting g1 as the root graph results in two stages (g1 in stage 1 and g2 and g3 in stage 2), but we could instead solve this problem with three stages by setting either g2 or g3 as the root graph by changing the second argument in the BendersOptimizer function in the code above. ","category":"page"},{"location":"PlasmoBenders/quickstart/#Optimizing-the-BendersOptimizer","page":"Quickstart","title":"Optimizing the BendersOptimizer","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"The BendersOptimizer object can be solved directly after initialization by calling JuMP.optimize!. This function has been extended from JuMP to solve the BendersOptimizer object. The solution approach includes performing the forward and backward pass","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.optimize!(benders_opt)","category":"page"},{"location":"PlasmoBenders/quickstart/#Querying-Solutions","page":"Quickstart","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoBenders.jl provides API functions for querying solutions and information from the BendersOptimizer object. Many of these are extended from JuMP. To query the objective, value, we can use","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.objective_value(benders_opt)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This returns the best upper bound. If PlasmoBenders has not converged to the requested tolerance, it will still return the best upper bound it has yet found. The lower bound can be queried by calling","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.dual_objective_value(benders_opt)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This returns the value of the lower bound. In the case of MIP problems, it is possible that there is a MIP gap and that certain tolerances cannot be reached. To see the relative gap between the lower and upper bound (i.e., the absolute value of the difference between the upper and lower bounds, normalized by the upper bound), you can call","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"relative_gap(benders_opt)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"In addition, there is functionality for querying the solution corresponding to the best upper bound. Individual variable values can be queried by calling","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.value(benders_opt, var)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"where var is the variable reference. Variables can be queried from the graph by pointing to the node and then pointing to the variable reference. For instance, we can query x[1] from g1 by calling g1[:n][:x][1]. In addition, we note that the JuMP.value function can normally take a single argument of a variable, but the extension we provide requires two arguments, with the first argument specifying the BendersOptimizer object. To query the solutions for a vector of variables, you can call","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.value(benders_opt, vars)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"where vars is a vector of variables, such as all_variables(g).","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nPlasmoBenders currently does not create a copy of the graph that is passed to the optimizer. This means that the user is discouraged from building the BendersOptimizer object and then altering the problem structure. In addition, if a user creates the BendersOptimizer object and then tries to optimize the graph or add to the graph, it may have unexpected solutions because of the addition of the cost-to-go variables and additional linking constraints. If the graph needs to be altered and the BendersOptimizer re-solved, it is recommended that the original graph be recreated and a new BendersOptimizer object built. ","category":"page"},{"location":"#PlasmoAlgorithms.jl","page":"Introduction","title":"PlasmoAlgorithms.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is a library of decomposition approaches in Julia that have been implemented for Plasmo.jl data structures. Plasmo is an open-source modeling package that constructs graph-structured optimization models. Plasmo is built on an abstraction called an OptiGraph, containing OptiNodes (with objectives, variables, and constraints) and OptiEdges (with constraints for variables on two or more nodes). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is intended to include different decomposition approaches that can exploit the graph structure of an optimization, and the implementation of these algorithms is based upon the graph structure. Currently, Benders Decomposition is implemented through the package PlasmoBenders.jl that is contained in this repository. PlasmoBenders.jl applies Benders and Nested Benders Decompositions to a problem defined by the user in Plasmo. PlasmoBenders applies these decomposition approaches based on the structure defined by the graph, where the graph structure dictates the complicating variables for the algorithm. Other decomposition approaches could likewise be developed similar to PlasmoBenders. We welcome contributions to the PlasmoAlgorithms suites. In addition, we encourage reporting issues and feature requests via the GitHub issue tracker..","category":"page"},{"location":"PlasmoBenders/graph_structure/#Graph-Structure-for-PlasmoBenders","page":"Exploiting Graph Structure","title":"Graph Structure for PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"The graph structure defined by the user determines how the Benders Decomposition (BD) or Nested Benders Decomposition (NBD) algorithms are applied for the given problem. One of the strengths of Plasmo is that it provides flexibility in structuring problems and provides users with flexibility in building the graphs. Below, we will highlight some basic points about the graph structure chosen by the user. Further details can be found in our preprint here.","category":"page"},{"location":"PlasmoBenders/graph_structure/#Subproblem-Representation","page":"Exploiting Graph Structure","title":"Subproblem Representation","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"PlasmoBenders applies BD and NBD based on the graph structure defined by the user, and we note here the objects that PlasmoBenders.jl uses for subproblems. Under previous versions of Plasmo (v0.5.4 and earlier), both nodes and subgraphs could be solved independently. Newer releases of Plasmo (v0.6 and on) are more sub-graph centric, and subgraphs are intended to be the \"subproblem\" objects. Plasmo supports nesting graphs within other graphs, such that you can have any \"level\" of nested graphs in a given OptiGraph. Any subgraph can be \"aggregated\" to form a node (i.e., the optimization problem on a graph can equivalently be represnted with a single node). For a given OptiGraph, mathcalG, PlasmoBenders expects the graph to be partitioned into subgraphs (i.e., all nodes in the mathcalG are contained on a subgraph), and these subgraphs are treated as the subproblems. Note that each of these subgraphs could likewise have nested subgraphs within them, but PlasmoBenders does not operate on these additional nested subgraphs. Thus, in the PlasmoBenders.BendersOptimizer, there are two required arguments: the optigraph mathcalG and a subgraph of mathcalG which will serve as the root subgraph. ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"It is possible that a user may want to use nodes as subproblems instead of subgraphs. PlasmoBenders provides a constructor function for this case and expects each node in the graph to be a subproblem. In this case, the user can pass a node of the graph to the BendersOptimizer constructor function. However, PlasmoBenders is designed to only operate with subgraphs, so in this node-based case, the graph will be partitioned into subgraphs with each node being on a separate subgraph. ","category":"page"},{"location":"PlasmoBenders/graph_structure/#Required-Graph-Structure","page":"Exploiting Graph Structure","title":"Required Graph Structure","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Both BD and NBD require the subgraphs to form a tree structure. This means that there are no cycles among the subgraphs. In other words, if you start at any subgraph i and move along the edges of the graph to any other subgraph j, you cannot return to subgraph i without traversing the same subgraphs as you did to reach subgraph j. PlasmoBenders, in constructing the BendersOptimizer object, will check structure and error out if the structure is not correct. The root subgraph specified by the user serves as a \"starting point\" for the graph structure, and each subgraph will then be placed into stages, with the root subgraph as the first stage. The second stage is all subgraphs connected by an edge to the root subgraph, the third stage is all subgraphs connected to subgraphs in stage two that does not include previous stages, and so forth. BD is a specific case of NBD where there are only two stages. These structures can be visualized as below, where the nodes aligned vertically can be considered in the same stage: ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: graph_structure)","category":"page"},{"location":"PlasmoBenders/graph_structure/#Building-the-Graph-Structure","page":"Exploiting Graph Structure","title":"Building the Graph Structure","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Some structures may initially look unfit for BD or NBD, but the flexibility in structuring and partitioning graphs provided by Plasmo can create the required structures. For instance, consider the following graph, where each \"node\" here can be considered its own subgraph.","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: grid graph)","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"This problem can be partitioned into different subgraphs to form the required tree structure. For instance, you can see below different partitioning schemes that result in different tree structures that can then be used for PlasmoBenders. Note that the dotted lines represent new subgraphs formed by partitioning.","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: grid graph partitioned)","category":"page"},{"location":"PlasmoBenders/graph_structure/#Algorithm-Performance","page":"Exploiting Graph Structure","title":"Algorithm Performance","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Importantly, how the algorithm performs will be dependent on the structure defined by a user. In the above example, each of the given partitionings could result in different algorithm performance. PlasmoBenders generalizes the BD and NBD algorithms to graph structure, but ther performance of these algorithms is dependent in large part on the mathematical problems that exist on the subgraphs. For instance, the choice of root graph will dictate which subgraphs receive cutting planes. Even in the case of two subgraphs connected by an edge, either subgraph could be treated as the root subgraph (or the master problem of BD). However, the master problem of BD is often deliberately chosen (e.g., it may contain all of the integer variables), and choosing one subgraph as the root graph over the other could drastically impact algorithm performance. ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"The user is therefore advised to use prior knowledge about their problem in choosing the root graph. Understanding the full impacts of the root graph choice or developing methods for choosing the root graph is an open area that, to our knowledge, has not yet been explored. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#System-Sizing","page":"Equipment Sizing","title":"System Sizing","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"This example is a simple example highlighting how PlasmoBenders can be applied to solve a problem using Benders Decomposition (BD). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Problem-Formulation","page":"Equipment Sizing","title":"Problem Formulation","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The example below is a simplified problem where we need to choose the size of a storage system and a reactor. In this problem, we are purchasing a raw material, x, that can be converted by a reactor into a product, y. There are varying costs for the raw material, and there are varying demands. We can store the raw material near the reactor, but the product must be produced to meet the demand (i.e., we are not storing the product). We have five options of storage size and five options of reactor size to choose from, and the costs are directly related to the size. The mathematical formulation of this problem is given below. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"beginalign*\n    min  alpha_storage s_size + alpha_reactor r_size + sum_t=1^T c^raw_t x^buy_t + beta y^unmet_t\n    textrmst  x^store_t+1 - x^store_t = x^save_t quad t = 1  T-1\n     y^product_t = gamma (x^buy_t - x^save_t) quad t = 1  T\n     y^unmet_t ge D_t - y^product_t quad t = 1  T \n     s_size = sum_i in N z^s_i lambda^storage_i quad sum_i in N z^s_i = 1  \n     r_size = sum_i in N z^r_i lambda^reactor_i quad sum_i in N z^r_i = 1  \n     0 le x^store_t le s_size quad t = 1  T \n     0 le x^buy_t - x^save_t le r_size quad t = 1  T\n     0 le x^sell_t le overlined^sell quad t = 1  T \n     underlined^save le x^save_t le overlined^save quad t = 1  T \n     x^store_1 = barx^store\nendalign*","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Here, x^buy_t is the amount of raw material purchased at time t, x^save is the amount of raw material sent to storage (can be negative if it is removed from storage), y^product_t is the amount of product created by the reactor to meet the demand, D_t, y^unmet_t is the unmet demand (which is penalized in the objective), s_size is the chosen size of the storage unit, and r_size is the chosen size of the reactor. In this problem, we assume that we have N possible storage unit sizes and N possible reactor sizes, represented by lambda^storage_i and lambda^reactor_i, respectively. The binary variables z^s_i and z^r_i ensure that the storage and reactor sizes are equal to the available sizes, and we constrain the sum of the binary variables for storage and for the reactor to be equal to one (i.e., only choose one size). The choice of storage unit and reactor size are then upper bounds on the total raw material stored or the amount of raw material sent to the reactor (note that x^buy_t - x^save is the amount of raw material sent to the reactor). The parameters alpha_storage, alpha_reactor, c^raw_t, and beta relate to the costs of their respective variables. gamma is a conversion factor of raw material to product. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Modeling-the-Problem-with-Plasmo","page":"Equipment Sizing","title":"Modeling the Problem with Plasmo","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We can model this problem using Plasmo. This problem can be thought of as a hierarchical optimization problem where we must consider a planning decision (storage unit and reactor sizes) that are going to have impacts on an operational level. To handle this, we will create two subgraphs. The first will be a planning-level subgraph containing the storage unit and reactor sizing decisions (s_size, r_size, z^s, and z^r) and their corresponding constraints. The second will be an operations-level subgraph containing the operation behavior (x^buy_t, x^store_t, x^save_t, y^product_t, y^unmet_t). These two layers will be linked by constraints on the lower-level subgraph. We will then treat the planning level OptiGraph as the root graph and use BD to solve this problem. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"First, we will define the cost and demand data we need for this problem. This can be done with the code snippet below: ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"using Random, Distributions\nt = 0:1:30\n\nRandom.seed!(10)\ncost1 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 10 .+ rand(Uniform(-1,1),31) .* .5\ndemand1 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 100 .+ rand(Uniform(-1,1),31) .* 5","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The resulting data can be visualized as shown below: ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"(Image: cost and demand)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Next, we will define the root (planning-level) graph. We add a node to this graph that will contain the storage unit and reactor sizing variables.","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Define graph and add a node\ng_root = OptiGraph()\n@optinode(g_root, n_root)\n\n# Set the possible storage and reactor sizes to choose from\nstorage_sizes = [10, 50, 100, 500, 1000]\nreactor_sizes = [10, 20, 50, 100, 200]\n\n# Define variables for the sizes and define binary variables for choosing sizes\n@variable(n_root, storage_size >= 0)\n@variable(n_root, reactor_size >= 0)\n@variable(n_root, storage_bin[1:5], Bin)\n@variable(n_root, reactor_bin[1:5], Bin)\n\n# Ensure that we choose one and only one size\n@constraint(n_root, sum(storage_bin) == 1)\n@constraint(n_root, sum(reactor_bin) == 1)\n\n# Set the size variables equal to the binary variables times their respective options\n@constraint(n_root, storage_size == sum(storage_bin[i] * storage_sizes[i] for i in 1:5))\n@constraint(n_root, reactor_size == sum(reactor_bin[i] * reactor_sizes[i] for i in 1:5))\n\n# Set the objective on the node\n@objective(n_root, Min, 5 * storage_size + 20 * reactor_size)\n\n# Set the objective on the graph\nset_to_node_objectives(g_root)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"In the code above, we have defined five options for storage sizes (10, 50, 100, 500, and 1000) and five options for reactor sizes (10, 20, 50, 100, and 200). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We will now also create the operations-level subgraph. We will define a function that takes a cost and demand value input and build the graph via that function (for reasons that will be discussed later).","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"function build_scenario_graph(cost, demand, num_scenarios = 1)\n    # Define time points\n    T = length(cost)\n    \n    # Define OptiGraph and nodes (one node for each time point)\n    g = OptiGraph()\n    @optinode(g, n[1:T])\n\n    # Loop through the nodes  and add variables and constraints\n    for (t, node) in enumerate(n)\n\n        # Define variables on the nodes\n        @variable(node, 0 <= x_buy )\n        @variable(node, -50 <= x_save <= 50)\n        @variable(node, 0 <= x_store)\n        @variable(node, 0 <= y_product)\n        @variable(node, 0 <= unmet_demand)\n\n        # Add constraints to the nodes\n        @constraint(node, unmet_demand >= demand[t] - y_product)\n        @constraint(node, y_product == 5 * (x_buy - x_save))\n\n        # Define objective on the node\n        @objective(node, Min, (unmet_demand * 1000 + x_buy * cost[t]) / num_scenarios)\n    end\n\n    # Set the initial storage amount\n    @constraint(n[1], n[1][:x_store] == 10)\n\n    # Link the storage variables acorss time points\n    @linkconstraint(g, [t = 1:(T-1)], n[t + 1][:x_store] - n[t][:x_store] == n[t][:x_save])\n    \n    # Set graph objective to summation of node objectives\n    set_to_node_objectives(g)\n\n    # Return the graph\n    return g\nend","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With the above function defined, we can now build a graph from our demand and cost data we defined. We will also define an overall graph g that will own the planning- and operations-level subgraphs. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define overall graph\ng = OptiGraph()\n\n# Define operations level subgraph\ng1 = build_scenario_graph(cost1, demand1)\n\n# Add subgraphs to graph `g`\nadd_subgraph!(g, g_root)\nadd_subgraph!(g, g1)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With these graphs created, the last thing to do is to create the linking constraints between the layers. We will force the storage unit and reactor sizes to be upper bounds on their respective variables by defining linking constraints between the two subgraphs. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define time points\nT = length(all_nodes(g1))\n\n# Define constraints on storage and reactor sizes\n@linkconstraint(g, [t = 1:T], g1[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g1[:n][t][:x_buy] - g1[:n][t][:x_save] <= g_root[:n_root][:reactor_size])","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Solving-with-PlasmoBenders","page":"Equipment Sizing","title":"Solving with PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The subgraphs of this problem form a tree structure (two subgraphs with edges connecting them), so we can now apply BD via PlasmoBenders. We will create the BendersOptimizer object by calling ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define a subproblem object to use for the subgraphs\nsolver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\n\n# Define the BendersOptimizer object and set the subproblem solver\nbenders_opt = BendersOptimizer(g, g_root, solver = solver)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The BendersOptimizer object can now be solved by calling ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"optimize!(benders_opt)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The upper and lower bounds and the gap from the BD algorithm are shown below. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"(Image: sizing results)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Here, the upper and lower bounds converge after 5 iterations. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"It can help to look at the solutions after each iteration to better understand how the algorithm is operation. At iteration 1, there are no cutting planes, and the root subgraph is solved first (independent of the operations-level). This means that it is only trying to minimize cost by choosing the least expensive options. Therefore, it chooses the smalles storage unit and reactor sizes (10 and 10). This is suboptimal in the operations-level; the cutting plane added after iteration 1 helps iteration 2 reach a better solution. In iteration 2, the root subgraph chooses a storage size of 10 and a reactor size of 50. This is a better solution but still suboptimal, and more cutting planes are added. At iteration 3, the root subgraph chooses a storage size of 500 and a reactor size of 50. This is actually a worse solution than the previous iteration, and an additional cutting plane is again added. At iteration 4, the root subgraph chooses a storage size of 50 and a reactor size of 50. This is in fact the optimal solution. However, we require one more iteration for the lower bound to converge. This is because the solution of the root subgraph yields a lower bound on the overall problem, but this root subgraph requires the cutting plane of the subproblem at iteration 4 before the lower bound converges to the optimal solution. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Adding-extra-scenarios","page":"Equipment Sizing","title":"Adding extra scenarios","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"This problem is relatively basic, but gives an idea of how PlasmoBenders can be applied. We could add complexity to this problem by making it stochastic. To do this, we could instead consider sizing the storage unit and the reactor size under different scenarios. We will create different demand and cost data and create subgraphs for each of these. In addition, we have to divide each scenario by the number of scenarios (this is assuming each scenario is equally likely, so this is just multiplying by each scenario's probability).","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define two new scenarios of demand and costs\ncost2 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 15 .+ rand(Uniform(-1,1),31) .* .75\ndemand2 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 90 .+ rand(Uniform(-1,1),31) .* 4.5\n\ncost3 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 8 .+ rand(Uniform(-1,1),31) .* .4\ndemand3 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 80 .+ rand(Uniform(-1,1),31) .* 4\n\n# Define overall graph\ng = OptiGraph()\n\n# Define subgraphs for each scenario\ng1 = build_scenario_graph(cost1, demand1, 3)\ng2 = build_scenario_graph(cost2, demand2, 3)\ng3 = build_scenario_graph(cost3, demand3, 3)\n\n# Add subgraphs to the original graph\nadd_subgraph!(g, g_root)\nadd_subgraph!(g, g1)\nadd_subgraph!(g, g2)\nadd_subgraph!(g, g3)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With these new subgraphs defined, we need to link the variables to the root graph. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Link variables of scenario 2 to root graph\n@linkconstraint(g, [t = 1:T], g2[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g2[:n][t][:x_buy] - g2[:n][t][:x_save] <= g_root[:n_root][:reactor_size])\n\n# Link variables of scneario 3 to root graph\n@linkconstraint(g, [t = 1:T], g3[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g3[:n][t][:x_buy] - g3[:n][t][:x_save] <= g_root[:n_root][:reactor_size])","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We can now call the BendersOptimizer function and solve this problem as before. In addition, if desired, we could set additional solver options, such as multicut = false (this uses one extra iteration) or regularize = true (which decreases the number of required iterations by 1). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"note: Note\nPlasmoBenders currently does not create a copy of the graph that is passed to the optimizer. This means that the graph g can't be altered with adding g2 and g3 after the original BendersOptimizer object is created. Instead, a new graph must be created and a new BendersOptimizer object must be formed for running the stochastic case above. ","category":"page"}]
}
