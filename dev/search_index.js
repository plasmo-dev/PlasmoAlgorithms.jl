var documenterSearchIndex = {"docs":
[{"location":"PlasmoBenders/algorithm/#Solution-Algorithm-for-PlasmoBenders.jl","page":"Algorithm","title":"Solution Algorithm for PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Benders and Nested Benders Decomposition are iterative algorithms, often used for solving large-scal problems. These algorithms are typically applied to linear programs (LP) and mixed-integer linear programs (MILP). They operate by iteratively solving smaller subproblems and sharing information between these subproblems (typically primal and dual) until an upper and lower bound converge or a different termination criteria is reached. A review of Benders decomposition and its applications can be found here, and an example of Nested Benders Decomposition (also referred to as Dual-Dynamic Programming) can be found here. This documentation will give an overview of the algorithms, but a full discussion of the algorithms can be found in the preprint on this package available here.","category":"page"},{"location":"PlasmoBenders/algorithm/#Benders-Decomposition","page":"Algorithm","title":"Benders Decomposition","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Benders Decomposition (BD) involves decomposing an optimization problem into a master problem and a subproblem(s) and solving these iteratively. The master problem contains a set of complicating variables that, when set, often makes the subproblem(s) easier to solve. The general approach of Benders is to solve the master problem and then to pass the solutions of the master problem to the subproblem(s) and to fix the solution of these variables in the subproblem(s). The subproblem(s) is then solved and information (often dual solutions) from the subproblem(s) is passed back to the master problem and is used to form \"cuts\" or \"cutting planes\" on the master problem. These cuts restrict the feasible region of the master problem, and the process is repeated after the cuts are added.","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"BD is applied to problems of the form ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_1^top x_1 + c_2^top x_2 \n    textrmst  A_1 x_1 + A_2 x_2 le b\n     C_1 x_1 le d_1 \n     C_2 x_2 le d_2\nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, the first constraint prevents us from separating this problem into two subproblems. We can solve this problem with BD by creating a master problem and a subproblem. The master problem has the form","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_1^top x_1 + theta \n    textrmst  C_1 x_1 le d_1 \n     theta ge textrmcuts \nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"where theta is the \"cost-to_go\" variable, which is an underestimate of the optimal value of the subproblem's optimal solution. The variable theta is constrained by cuts that are generated at each iteration of the BD algorithm. The subproblem has the form ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  c_2^top x_2\n    textrmst  C_2 x_2 le d_2 \n     A_1 z + A_2 x_2 le b \n     z = barx_2 quad (lambda)\nendalign*","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"where barx is the solution of the master problem at the last iteration and lambda is the dual variable for the corresponding constraint. Note that the constraint A_1z + A_2x_2 le b is enforced at the subproblem level, which ensures that the solution fo the master problem and subproblem is a feasible solution of the original problem (assuming complete recourse). Since theta is an underestimate of the optimal value of the subproblem, solving the master problem produces a lower bound on the original problem's solution. Each iteration of the algorithm (assuming complete recourse) results in a feasible solution to the original problem which forms an upper bound on the original optimization problem.","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"A visualization of BD for graphs is shown below. Here, the graph on the left has two subgraphs with an edge between them. One of the subgraphs can be treated as the \"master\" problem, and the other as the \"subproblem.\" The cost-to-go variable is added to the master problem along with the cutting plane restrictions. The solutions of the master problem are then fixed in the subproblem. These problems are iteratively solved until a solution is reached. ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: BD)","category":"page"},{"location":"PlasmoBenders/algorithm/#Nested-Benders-Decomposition","page":"Algorithm","title":"Nested Benders Decomposition","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"Nested Benders Decomposition (NBD) is similar to BD but includes more than two \"stages\" of problems. BD can be considered a \"two-stage\" problem where the master problem is the first stage, which is then linked to a subproblem in a \"second\" stage. In NBD, There can be additional subproblems, such that the subproblem in stage two can contain complicating variables for an additional subproblem in a third stage, and so forth. This can be visualized as shown below. ","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: NBD)","category":"page"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"In NBD, there is a \"forward-pass\" where each stage is solved sequentially and primal solutions are shared to and fixed in the next stage. After each stage has been solved, information can be shared to the previous stage in a \"backward-pass\" to form cutting planes on each previous stage. ","category":"page"},{"location":"PlasmoBenders/algorithm/#Implementation-in-PlasmoBenders.jl","page":"Algorithm","title":"Implementation in PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/algorithm/","page":"Algorithm","title":"Algorithm","text":"PlasmoBenders.jl implements the NBD algorithm. BD can be considered a specialized case of NBD, such that we only need to implement a single algorithm in the code. There are many additional parameters and techniques that NBD can include, and these are covered in other pages of the documentation. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#System-Sizing","page":"Equipment Sizing","title":"System Sizing","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"This example is a simple example highlighting how PlasmoBenders can be applied to solve a problem using Benders Decomposition (BD). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Problem-Formulation","page":"Equipment Sizing","title":"Problem Formulation","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The example below is a simplified problem where we need to choose the size of a storage system and a reactor. In this problem, we are purchasing a raw material, x, that can be converted by a reactor into a product, y. There are varying costs for the raw material, and there are varying demands. We can store the raw material near the reactor, but the product must be produced to meet the demand (i.e., we are not storing the product). We have five options of storage size and five options of reactor size to choose from, and the costs are directly related to the size. The mathematical formulation of this problem is given below. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"beginalign*\n    min  alpha_storage s_size + alpha_reactor r_size + sum_t=1^T c^raw_t x^buy_t + beta y^unmet_t\n    textrmst  x^store_t+1 - x^store_t = x^save_t quad t = 1  T-1\n     y^product_t = gamma (x^buy_t - x^save_t) quad t = 1  T\n     y^unmet_t ge D_t - y^product_t quad t = 1  T \n     s_size = sum_i in N z^s_i lambda^storage_i quad sum_i in N z^s_i = 1  \n     r_size = sum_i in N z^r_i lambda^reactor_i quad sum_i in N z^r_i = 1  \n     0 le x^store_t le s_size quad t = 1  T \n     0 le x^buy_t - x^save_t le r_size quad t = 1  T\n     0 le y^product_t le overlined^sell quad t = 1  T \n     underlined^save le x^save_t le overlined^save quad t = 1  T \n     x^store_1 = barx^store\nendalign*","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Here, x^buy_t is the amount of raw material purchased at time t, x^save is the amount of raw material sent to storage (can be negative if it is removed from storage), y^product_t is the amount of product created by the reactor to meet the demand, D_t, y^unmet_t is the unmet demand (which is penalized in the objective), s_size is the chosen size of the storage unit, and r_size is the chosen size of the reactor. In this problem, we assume that we have N possible storage unit sizes and N possible reactor sizes, represented by lambda^storage_i and lambda^reactor_i, respectively. The binary variables z^s_i and z^r_i ensure that the storage and reactor sizes are equal to the available sizes, and we constrain the sum of the binary variables for storage and for the reactor to be equal to one (i.e., only choose one size). The choice of storage unit and reactor size are then upper bounds on the total raw material stored or the amount of raw material sent to the reactor (note that x^buy_t - x^save is the amount of raw material sent to the reactor). The parameters alpha_storage, alpha_reactor, c^raw_t, and beta relate to the costs of their respective variables. gamma is a conversion factor of raw material to product. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Modeling-the-Problem-with-Plasmo","page":"Equipment Sizing","title":"Modeling the Problem with Plasmo","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We can model this problem using Plasmo. This problem can be thought of as a hierarchical optimization problem where we must consider a planning decision (storage unit and reactor sizes) that are going to have impacts on an operational level. To handle this, we will create two subgraphs. The first will be a planning-level subgraph containing the storage unit and reactor sizing decisions (s_size, r_size, z^s, and z^r) and their corresponding constraints. The second will be an operations-level subgraph containing the operation behavior (x^buy_t, x^store_t, x^save_t, y^product_t, y^unmet_t). These two layers will be linked by constraints on the lower-level subgraph. We will then treat the planning level OptiGraph as the root graph and use BD to solve this problem. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"First, we will define the cost and demand data we need for this problem. This can be done with the code snippet below: ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"using Random, Distributions\nt = 0:1:30\n\nRandom.seed!(10)\ncost1 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 10 .+ rand(Uniform(-1,1),31) .* .5\ndemand1 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 100 .+ rand(Uniform(-1,1),31) .* 5","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The resulting data can be visualized as shown below: ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"(Image: cost and demand)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Next, we will define the root (planning-level) graph. We add a node to this graph that will contain the storage unit and reactor sizing variables.","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Define graph and add a node\ng_root = OptiGraph()\n@optinode(g_root, n_root)\n\n# Set the possible storage and reactor sizes to choose from\nstorage_sizes = [10, 50, 100, 500, 1000]\nreactor_sizes = [10, 20, 50, 100, 200]\n\n# Define variables for the sizes and define binary variables for choosing sizes\n@variable(n_root, storage_size >= 0)\n@variable(n_root, reactor_size >= 0)\n@variable(n_root, storage_bin[1:5], Bin)\n@variable(n_root, reactor_bin[1:5], Bin)\n\n# Ensure that we choose one and only one size\n@constraint(n_root, sum(storage_bin) == 1)\n@constraint(n_root, sum(reactor_bin) == 1)\n\n# Set the size variables equal to the binary variables times their respective options\n@constraint(n_root, storage_size == sum(storage_bin[i] * storage_sizes[i] for i in 1:5))\n@constraint(n_root, reactor_size == sum(reactor_bin[i] * reactor_sizes[i] for i in 1:5))\n\n# Set the objective on the node\n@objective(n_root, Min, 5 * storage_size + 20 * reactor_size)\n\n# Set the objective on the graph\nset_to_node_objectives(g_root)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"In the code above, we have defined five options for storage sizes (10, 50, 100, 500, and 1000) and five options for reactor sizes (10, 20, 50, 100, and 200). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We will now also create the operations-level subgraph. We will define a function that takes a cost and demand value input and build the graph via that function (for reasons that will be discussed later).","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"function build_scenario_graph(cost, demand, num_scenarios = 1)\n    # Define time points\n    T = length(cost)\n    \n    # Define OptiGraph and nodes (one node for each time point)\n    g = OptiGraph()\n    @optinode(g, n[1:T])\n\n    # Loop through the nodes  and add variables and constraints\n    for (t, node) in enumerate(n)\n\n        # Define variables on the nodes\n        @variable(node, 0 <= x_buy )\n        @variable(node, -50 <= x_save <= 50)\n        @variable(node, 0 <= x_store)\n        @variable(node, 0 <= y_product)\n        @variable(node, 0 <= unmet_demand)\n\n        # Add constraints to the nodes\n        @constraint(node, unmet_demand >= demand[t] - y_product)\n        @constraint(node, y_product == 5 * (x_buy - x_save))\n\n        # Define objective on the node\n        @objective(node, Min, (unmet_demand * 1000 + x_buy * cost[t]) / num_scenarios)\n    end\n\n    # Set the initial storage amount\n    @constraint(n[1], n[1][:x_store] == 10)\n\n    # Link the storage variables acorss time points\n    @linkconstraint(g, [t = 1:(T-1)], n[t + 1][:x_store] - n[t][:x_store] == n[t][:x_save])\n    \n    # Set graph objective to summation of node objectives\n    set_to_node_objectives(g)\n\n    # Return the graph\n    return g\nend","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With the above function defined, we can now build a graph from our demand and cost data we defined. We will also define an overall graph g that will own the planning- and operations-level subgraphs. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define overall graph\ng = OptiGraph()\n\n# Define operations level subgraph\ng1 = build_scenario_graph(cost1, demand1)\n\n# Add subgraphs to graph `g`\nadd_subgraph!(g, g_root)\nadd_subgraph!(g, g1)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With these graphs created, the last thing to do is to create the linking constraints between the layers. We will force the storage unit and reactor sizes to be upper bounds on their respective variables by defining linking constraints between the two subgraphs. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define time points\nT = length(all_nodes(g1))\n\n# Define constraints on storage and reactor sizes\n@linkconstraint(g, [t = 1:T], g1[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g1[:n][t][:x_buy] - g1[:n][t][:x_save] <= g_root[:n_root][:reactor_size])","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Solving-with-PlasmoBenders","page":"Equipment Sizing","title":"Solving with PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The subgraphs of this problem form a tree structure (two subgraphs with edges connecting them), so we can now apply BD via PlasmoBenders. We will create the BendersAlgorithm object by calling ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define a subproblem object to use for the subgraphs\nsolver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\n\n# Define the BendersAlgorithm object and set the subproblem solver\nbenders_alg = BendersAlgorithm(g, g_root, solver = solver)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The BendersAlgorithm object can now be solved by calling ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"run_algorithm!(benders_alg)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"The upper and lower bounds and the gap from the BD algorithm are shown below. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"(Image: sizing results)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"Here, the upper and lower bounds converge after 5 iterations. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"It can help to look at the solutions after each iteration to better understand how the algorithm is operation. At iteration 1, there are no cutting planes, and the root subgraph is solved first (independent of the operations-level). This means that it is only trying to minimize cost by choosing the least expensive options. Therefore, it chooses the smalles storage unit and reactor sizes (10 and 10). This is suboptimal in the operations-level; the cutting plane added after iteration 1 helps iteration 2 reach a better solution. In iteration 2, the root subgraph chooses a storage size of 10 and a reactor size of 50. This is a better solution but still suboptimal, and more cutting planes are added. At iteration 3, the root subgraph chooses a storage size of 500 and a reactor size of 50. This is actually a worse solution than the previous iteration, and an additional cutting plane is again added. At iteration 4, the root subgraph chooses a storage size of 50 and a reactor size of 50. This is in fact the optimal solution. However, we require one more iteration for the lower bound to converge. This is because the solution of the root subgraph yields a lower bound on the overall problem, but this root subgraph requires the cutting plane of the subproblem at iteration 4 before the lower bound converges to the optimal solution. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/#Adding-extra-scenarios","page":"Equipment Sizing","title":"Adding extra scenarios","text":"","category":"section"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"This problem is relatively basic, but gives an idea of how PlasmoBenders can be applied. We could add complexity to this problem by making it stochastic. To do this, we could instead consider sizing the storage unit and the reactor size under different scenarios. We will create different demand and cost data and create subgraphs for each of these. In addition, we have to divide each scenario by the number of scenarios (this is assuming each scenario is equally likely, so this is just multiplying by each scenario's probability).","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Define two new scenarios of demand and costs\ncost2 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 15 .+ rand(Uniform(-1,1),31) .* .75\ndemand2 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 90 .+ rand(Uniform(-1,1),31) .* 4.5\n\ncost3 = sin.(x .* 2 .* pi ./ 10 ) .* 2 .+ 8 .+ rand(Uniform(-1,1),31) .* .4\ndemand3 = sin.(x .* 2 .* pi ./ 15 ) .* 30 .+ 80 .+ rand(Uniform(-1,1),31) .* 4\n\n# Define overall graph\ng = OptiGraph()\n\n# Define subgraphs for each scenario\ng1 = build_scenario_graph(cost1, demand1, 3)\ng2 = build_scenario_graph(cost2, demand2, 3)\ng3 = build_scenario_graph(cost3, demand3, 3)\n\n# Add subgraphs to the original graph\nadd_subgraph!(g, g_root)\nadd_subgraph!(g, g1)\nadd_subgraph!(g, g2)\nadd_subgraph!(g, g3)","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"With these new subgraphs defined, we need to link the variables to the root graph. ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"# Link variables of scenario 2 to root graph\n@linkconstraint(g, [t = 1:T], g2[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g2[:n][t][:x_buy] - g2[:n][t][:x_save] <= g_root[:n_root][:reactor_size])\n\n# Link variables of scneario 3 to root graph\n@linkconstraint(g, [t = 1:T], g3[:n][t][:x_store] <= g_root[:n_root][:storage_size])\n@linkconstraint(g, [t = 1:T], g3[:n][t][:x_buy] - g3[:n][t][:x_save] <= g_root[:n_root][:reactor_size])","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"We can now call the BendersAlgorithm function and solve this problem as before. In addition, if desired, we could set additional solver options, such as multicut = false (this uses one extra iteration) or regularize = true (which decreases the number of required iterations by 1). ","category":"page"},{"location":"PlasmoBenders/sizing_tutorial/","page":"Equipment Sizing","title":"Equipment Sizing","text":"note: Note\nPlasmoBenders currently does not create a copy of the graph that is passed to the optimizer. This means that the graph g can't be altered with adding g2 and g3 after the original BendersAlgorithm object is created. Instead, a new graph must be created and a new BendersAlgorithm object must be formed for running the stochastic case above. ","category":"page"},{"location":"PlasmoBenders/api_docs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"PlasmoBenders/api_docs/#API-Manual","page":"API Documentation","title":"API Manual","text":"","category":"section"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.AbstractPBAlgorithm","page":"API Documentation","title":"PlasmoBenders.AbstractPBAlgorithm","text":"AbstractPBAlgorithm{T}\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersAlgorithm","page":"API Documentation","title":"PlasmoBenders.BendersAlgorithm","text":"BendersAlgorithm\n\nOptimizer object for dual dynamic programming with graphs. Currently only implemented for linear tree structures.\n\nAttributes include the following (where noted as dictionaries, these are mappings from the Benders subproblems to the data described)\n\ngraph - Plasmo OptiGraph for appplying Benders\nroot_object - node or subgraph in graph indicating where to start the Benders algorithm\nis_MIP = Boolean indicating if the problem is a MIP or not\nsolve_order - vector of OptiNodes in the order that they are solved by Benders\nsolve_order_dict - dictionary mapping to a vector of all the \"next objects\" for a given object\nparent_objects - dictionary mapping to the previous subproblem\nmax_iters - maximum number of Benders iterations\ntime_limit - maximum time (seconds) allowed for running Benders\ntol - (absolute) termination tolerance between upper and lower bounds\ncurrent_iter - current iteration of Benders algorithm\nM - lower bound for the cost-to-go function at each iteration\ndual_iters - dictionary mapping optinodes to the corresponding dual values  at each iteration; dual values come from solution of following node\nprimal_iters - dictionary mapping optinodes to the primal solutions of the  complicating variables on the given node\nphis - dictionary mapping optinodes to the objective of the immediately following node\nphis_LR - dictionary mapping optinodes to the objective of the lagrangean (used for strenghtened cuts)  relaxation of the following node; used for strengthened Benders cuts in MIPs\ntime_forward_pass - time spent in the forward pass (seconds)\ntime_backward_pass - time spent in the backward pass (seconds)\ntime_init - time initializing the optimizer (seconds)\ntime_iterations - vector of the times spent in each Iteration\ncomp_vars - dictionary mapping the node to a vector of its complicating variables\ncomp_var_map - dictionary mapping the node to a dictionary of complicating variables  mapped to their index in comp_vars\nvar_copy_map - dictionary mapping the node to a dictionary mapping the complicating  variables to their copies on the following node\nobjective_value - the final objective value (from upper bound)\nlower_bounds - vector of lower bounds at each iteration\nupper_bounds - vector of upper bounds at each iteration\nregularize_data - regularization data object\nbinary_map - dictionary mapping the nodes to a vector of binary variables on the node\ninteger_map - dictionary mapping the nodes to a vector of integer variables on the node\nlast_solutions - dictionary mapping the nodes to a vector of the last solutions\nvar_solution_map - dictionary mapping the variables to their index on the last_solutions vector\nvar_to_graph_map - dictionary mapping the variables to their owning subproblem subgraph\nfeasibility_map - dictionary matching solve_order for whether a problem was feasible or not\noptions - solver options for Benders algorithm\next - Dictionary for extending certain procedures\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersAlgorithm-Union{Tuple{T}, Tuple{OptiGraph, T}} where T<:OptiNode","page":"API Documentation","title":"PlasmoBenders.BendersAlgorithm","text":"BendersAlgorithm(graph, root_object; kwargs...)\n\nFunction for creating the BendersAlgorithm object from graph. root_object must be an OptiNode or subgraph on graph. key ward arguments include the following\n\nmax_iters = 100 - maximum number of iterations\ntol = 1e-7 - termination tolerance between upper and lower bounds\nM = 0 - lower bound on cost-to-go estimator for each node\nis_MIP = nothing - indicates if the problem is a MIP. If it is passed as nothing,  PlasmoBenders will check to see if it is a MIP, and will set is_MIP accordingly\nsolver = nothing - if defined, this solver will be set for all subproblems\nstrengthened = false - whether to use strengthened Benders cuts (see https://doi.org/10.1007/s10107-018-1249-5.)\nmulticut = true - whether to use multicuts (rather than aggregated cuts) when applicable\nfeasibility_cuts = false - whether to allow feasibility cuts\nregularize = false - whether to regularize solution of next iterates\nparallelize_benders = false - whether to parallelize subproblem solution when the problem has a Benders-type structure defined\nparallelize_forward = false - whether to parallelize forward pass if possible; not yet supported\nparallelize_backward = false - whether to parallelize backward pass\nadd_slacks::Bool = false - whether to add slack variables to the linking constraints to  help ensure feasibility between solutions; slack variables are penalized in objective\nfix_slacks = false - whether to fix the slack variables to zero they only relax if a problem is infeasible\nwarm_start::Bool = true - whether to set the previous iterations solutions as the  starting values for the next iterations forward pass\nrelaxed_init_cuts = false - whether to generate initial cuts by relaxing the problem and solving the whole problem; only applies for MILPs\nslack_penalty = 1e6 - coefficient on slack variables in objective\nregularize_param = 0.5 - regularization parameter; must be between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.BendersOptions","page":"API Documentation","title":"PlasmoBenders.BendersOptions","text":"BendersOptions\n\nOptions object for dual dynamic programming with graphs\n\nAttributes include\n\nstrengthened::Bool - whether to use strengthened cuts\nmulticut::Bool - whether the problem should use aggregated or multiple cuts when there are multiple objects generating information in the forward pass\nfeasibility_cuts::Bool - whether to allow feasibility cuts if infeasible\nregularize::Bool - whether to used regularization for getting next cuts\nparallelize_benders::Bool - whether to parallelize Benders problems if applicable\nparallelize_forward::Bool - whether to parallelize the forward pass if possible\nparallelize_backward::Bool - whether to parallelize the backward pass if possible\nadd_slacks::Bool - whether to add slack variables to linking constraints\nfix_slacks::Bool - whether to fix the slack variables to zero; slacks will be relaxed if the problem is infeasible\nwarm_start::Bool - whether to warm start the problem using the previous best solution\nrelaxed_init_cuts::Bool - whether to create some initial cuts by relaxing the problem and solving the full problem as an LP; only applies if the problem is a MIP\nslack_penalty::Real - penalty for nonzero slacks; only applies for add_slacks = true\nregularize_param::Real - parameter for regularization; essentially how far from optimal the solution can end up being for choosing the next iterates.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.RegularizeData","page":"API Documentation","title":"PlasmoBenders.RegularizeData","text":"RegularizeData\n\nData structure for storing regularization data\n\nAll attributes include a dictionary which is indexed by the subproblem objects of Benders\n\nobjective_function - the objective function of an object\nubs - value of the object's objective (without theta)\nlbs - value of the object's objective (with theta)\nbest_ub - best upper bound\n\n\n\n\n\n","category":"type"},{"location":"PlasmoBenders/api_docs/#JuMP.value-Tuple{BendersAlgorithm, NodeVariableRef}","page":"API Documentation","title":"JuMP.value","text":"JuMP.value(opt::BendersAlgorithm, var::NodeVariableRef)\n\nReturns the value of var from the BendersAlgorithm object. The value corresponds to the best upper bound of the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#JuMP.value-Tuple{BendersAlgorithm, Vector{NodeVariableRef}}","page":"API Documentation","title":"JuMP.value","text":"JuMP.value(opt::BendersAlgorithm, vars::Vector{NodeVariableRef})\n\nReturns a vector of variables contained in the vars vector from the BendersAlgorithm object. The values correspond to the best upper bound of the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_Benders_cut_to_object!-Union{Tuple{G}, Tuple{BendersAlgorithm, G, Vector{G}}} where G<:Plasmo.AbstractOptiGraph","page":"API Documentation","title":"PlasmoBenders._add_Benders_cut_to_object!","text":"_add_Benders_cut_to_object!(optimizer, last_object, next_objects)\n\nAdd cuts to a given object\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_Benders_cuts!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._add_Benders_cuts!","text":"_add_Benders_cuts!(optimizer::BendersAlgorithm)\n\nAdd Benders cuts to each nested problem; uses results from the backward pass and forward pass to create cuts.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_initial_relaxed_cuts!-Union{Tuple{BendersAlgorithm{T}}, Tuple{T}} where T<:Union{OptiGraph, OptiNode}","page":"API Documentation","title":"PlasmoBenders._add_initial_relaxed_cuts!","text":"_add_initial_relaxed_cuts!(optimizer::BendersAlgorithm)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_strengthened_cut_to_object!-Union{Tuple{G}, Tuple{BendersAlgorithm, G, Vector{G}}} where G<:Plasmo.AbstractOptiGraph","page":"API Documentation","title":"PlasmoBenders._add_strengthened_cut_to_object!","text":"_add_strengthened_cut_to_object!(optimizer, last_object, next_objects)\n\nAdd cuts to a given object\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._add_strengthened_cuts!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._add_strengthened_cuts!","text":"_add_strengthened_cuts!(optimizer::BendersAlgorithm)\n\nAdd strengthened Benders cuts to each nested problem; Follows the process described by Zou et al., 2019 (https://doi.org/10.1007/s10107-018-1249-5) where the cuts come from a Lagrangian relaxation where the lagrange multipliers are the dual variables of the backward pass.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._backward_pass!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._backward_pass!","text":"_backward_pass!(optimizer::BendersAlgorithm)\n\nPerform backward pass for a MIP problem. Backward pass can be done in parallel. Binary and integer variables are relaxed and the problem is solved to get the dual and objective values for producing Benders cuts. If strengthened = true, the stengthened cuts are ALSO added using the approach of Zou et al. https://doi.org/10.1007/s10107-018-1249-5.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders._forward_pass!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders._forward_pass!","text":"_forward_pass!(optimizer::BendersAlgorithm)\n\nRuns the forward pass for Benders. Follows the node order in solve_order attribute. Save the primal information for complicating variables on each node. If it is not a MIP, also saves the dual and objective value information and adds the Benders cut. Returns the upper and lower bounds, where lower bound is only valid if the problem is not a MIP (otherwise the lower bound comes from the backward pass)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_add_slacks-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_add_slacks","text":"get_add_slacks(optimizer::BendersAlgorithm)\n\nReturn the value of add_slacks from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_feasibility_cuts-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_feasibility_cuts","text":"get_feasibility_cuts(optimizer::BendersAlgorithm)\n\nReturn the value of feasibility_cuts from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_fix_slacks-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_fix_slacks","text":"get_fix_slacks(optimizer::BendersAlgorithm)\n\nReturn the value of fix_slacks from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_graph-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_graph","text":"get_graph(optimizer::BendersAlgorithm)\n\nReturn the value of the graph attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_is_MIP-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_is_MIP","text":"get_is_MIP(optimizer::BendersAlgorithm)\n\nReturn the value of the is_MIP attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_lower_bounds-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_lower_bounds","text":"get_lower_bounds(optimizer::BendersAlgorithm)\n\nReturn the value of the lower_bounds attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_max_iters-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_max_iters","text":"get_max_iters(optimizer::BendersAlgorithm)\n\nReturn the value of the max_iters attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_multicut-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_multicut","text":"get_multicut(optimizer::BendersAlgorithm)\n\nReturn the value of multicut from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_backward-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_backward","text":"get_parallelize_backward(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_backward from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_benders-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_benders","text":"get_parallelize_benders(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_benders from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_parallelize_forward-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_parallelize_forward","text":"get_parallelize_forward(optimizer::BendersAlgorithm)\n\nReturn the value of parallelize_forward from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize","text":"get_regularize(optimizer::BendersAlgorithm)\n\nReturn the value of regularize from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_best_ub-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_best_ub","text":"get_regularize_best_ub(optimizer::BendersAlgorithm)\n\nReturn the value of bestub from the `regularizedatafield of theBendersAlgorithm`\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_constraint-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_constraint","text":"get_regularize_constraint(optimizer::BendersAlgorithm)\n\nReturn the value of constraint from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_lbs-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_lbs","text":"get_regularize_lbs(optimizer::BendersAlgorithm)\n\nReturn the value of lbs from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_objective_function-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_objective_function","text":"get_regularize_objective_function(optimizer::BendersAlgorithm)\n\nReturn the value of objectivefunction from the `regularizedatafield of theBendersAlgorithm`\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_param-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_param","text":"get_regularize_param(optimizer::BendersAlgorithm)\n\nReturn the value of regularize_param from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_slack-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_slack","text":"get_regularize_slack(optimizer::BendersAlgorithm)\n\nReturn the value of slack from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_regularize_ubs-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_regularize_ubs","text":"get_regularize_ubs(optimizer::BendersAlgorithm)\n\nReturn the value of ubs from the regularize_data field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_relaxed_init_cuts-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_relaxed_init_cuts","text":"get_relaxed_init_cuts(optimizer::BendersAlgorithm)\n\nReturn the value of relaxedinitcuts from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_root_object-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_root_object","text":"get_root_object(optimizer::BendersAlgorithm)\n\nReturn the value of the root_object attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_sequential_backward_pass-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_sequential_backward_pass","text":"get_sequential_backward_pass(optimizer::BendersAlgorithm)\n\nReturn the value of sequentialbackwardpass from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_slack_penalty-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_slack_penalty","text":"get_slack_penalty(optimizer::BendersAlgorithm)\n\nReturn the value of slack_penalty from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_strengthened-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_strengthened","text":"get_strengthened(optimizer::BendersAlgorithm)\n\nReturn the value of strengthened from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_time_backward_pass-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_time_backward_pass","text":"get_time_backward_pass(optimizer::BendersAlgorithm)\n\nReturn the value of the timebackwardpass attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_time_forward_pass-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_time_forward_pass","text":"get_time_forward_pass(optimizer::BendersAlgorithm)\n\nReturn the value of the timeforwardpass attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_time_init-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_time_init","text":"get_time_init(optimizer::BendersAlgorithm)\n\nReturn the value of the time_init attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_time_iterations-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_time_iterations","text":"get_time_iterations(optimizer::BendersAlgorithm)\n\nReturn the value of the time_iterations attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_time_limit-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_time_limit","text":"get_time_limit(optimizer::BendersAlgorithm)\n\nReturn the value of the time_limit attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_tol-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_tol","text":"get_tol(optimizer::BendersAlgorithm)\n\nReturn the value of the tol attribute from the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_upper_bounds-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_upper_bounds","text":"get_upper_bounds(optimizer::BendersAlgorithm; monotonic = true)\n\nReturn the value of upper_bounds from the BendersAlgorithm object. This is a vector of the upper bounds at each iteration. The upper bound returned by each iteration is not guaranteed to decrease monotonically. If monotonic=true, this function returns the best upper bound seen up to each iteration (rather than the value of the feasible solution seen at that iteration)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.get_warm_start-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.get_warm_start","text":"get_warm_start(optimizer::BendersAlgorithm)\n\nReturn the value of warm_start from the options field of the BendersAlgorithm\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.run_algorithm!-Tuple{BendersAlgorithm}","page":"API Documentation","title":"PlasmoBenders.run_algorithm!","text":"run_algorithm!(optimizer::PB.BendersAlgorithm; output::Bool = true, run_gc::Bool = false)\n\nOptimize the graph in BendersAlgorithm by using the Benders algorithm. Keyword argument output indicates whether to print the upper/lower bounds and gap and each iteraiton. run_gc indicates whether to run the garbage collector after each iteraiton. \n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_add_slacks!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_add_slacks!","text":"set_add_slacks!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of add_slacks from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_feasibility_cuts!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_feasibility_cuts!","text":"set_feasibility_cuts!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of feasibility_cuts from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_fix_slacks!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_fix_slacks!","text":"set_fix_slacks!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of fix_slacks from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_multicut!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_multicut!","text":"set_multicut!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of multicut from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_backward!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_backward!","text":"set_parallelize_backward!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_backward from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_benders!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_benders!","text":"set_parallelize_benders!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_benders from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_parallelize_forward!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_parallelize_forward!","text":"set_parallelize_forward!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of parallelize_forward from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_regularize!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_regularize!","text":"set_regularize!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of regularize from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_regularize_param!-Tuple{BendersAlgorithm, Real}","page":"API Documentation","title":"PlasmoBenders.set_regularize_param!","text":"set_regularize_param!(optimizer::BendersAlgorithm, val::Real)\n\nSet the value of regularize_param from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_relaxed_init_cuts!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_relaxed_init_cuts!","text":"set_relaxed_init_cuts!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of relaxedinitcuts from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_sequential_backward_pass!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_sequential_backward_pass!","text":"set_sequential_backward_pass!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of sequentialbackwardpass from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_slack_penalty!-Tuple{BendersAlgorithm, Real}","page":"API Documentation","title":"PlasmoBenders.set_slack_penalty!","text":"set_slack_penalty!(optimizer::BendersAlgorithm, val::Real)\n\nSet the value of slack_penalty from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_strengthened!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_strengthened!","text":"set_strengthened!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of strengthened from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/api_docs/#PlasmoBenders.set_warm_start!-Tuple{BendersAlgorithm, Bool}","page":"API Documentation","title":"PlasmoBenders.set_warm_start!","text":"set_warm_start!(optimizer::BendersAlgorithm, val::Bool)\n\nSet the value of warm_start from the options field of the BendersAlgorithm to val\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/solver/#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"PlasmoBenders supports several different solver options. These are keyword arguments that can be  These include the following: ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"strengthened::Bool - whether to use \"strengthened\" Benders cuts for MILP problems. These cuts are outlined here and here. They add some computational time to the algorithm but can result in tighter cuts (and thus fewer iterations or a smaller duality gap) being added to the subproblems. This only applies if there are integer variables in the subproblems (not just the root subgraph). Currently, these only work for MILP problems, not for LP problems.\nmulticut::Bool - Whether to use multi-cuts (instead of aggregated cuts). When a subproblem has multiple children subgraphs (i.e., is connected to multiple subproblems in the next stage), you can use either an aggregated cut (where there is a single cost-to-go variable) or multi-cuts, where each child subproblem has its own corresponding cost-to-go function. Multi-cuts result in more cutting planes being added at each iteration, but aggregated cuts result in fewer overall constraints being added. \nfeasibility_cuts::Bool - Whether to allow for feasibility cuts. These are implemented following JuMP.jl's documentation and are currently only implemented for two-stage problems for LP or MILP problems. These cuts are added when the second stage subproblem(s) are infeasible, and they require using multicut = true. \nregularize::Bool - Whether to use a regularization scheme to choose the solutions passed to the next stage. PlasmoBenders implements the regularization scheme from here. The regularization only works for Benders Decomposition (BD; i.e., 2-stage problems). This scheme chooses points that are normally interior, feasible points in the master problem. Does not work with warm_start=true.\nregularize_param::Real - A parameter between 0 and 1 that influences how far inside the feasible region the regularization can choose a solution.\nparallelize_benders::Bool - For BD, whether to parallelize the solution of the second stage subgraphs if multiple subgraphs exist.\nparallelize_forward::Bool - Not currently supported. We hope to implement this functionality in the future\nparallelize_backward::Bool - Whether to parallelize the backwards pass.\nadd_slacks::Bool - Whether to add slack variables to the linking constraint that is enforced on the downstream problem. This helps ensure recourse to the subproblems.\nslack_penalty::Real - THe value of the penalty term used on the slack variables added to the linking constraints. \nfix_slacks::Bool - An experimental option where slack variables are fixed until a problem is infeasible, in which case, the slack variables are allowed to be unfixed to make the problem feasible. THere are no convergence guarantees on this approach.\nwarm_start::Bool - Whether to warm start the problems with the best solution that the solver has found so far. Cannot be true if regularize=true. \nrelaxed_init_cuts::Bool - Whether to add initial cuts from a full problem relaxation. For MILP problems, initial cuts can be added by relaxing all integer variables and solving the full problem, and using the resulting primal/dual information to form cutting planes. See Lara.\nmax_iters::Int - The maximum number of iterations to use before termination.\ntol::Real - The relative tolerance between the upper and lower bounds to reach before termination. \nsolver - The subproblem solver to use. If this is not set, it will assume that the user has set a solver on all subgraphs. \nM::Real - Lower bound on all cost-to-go variables. Default value is 0. At the first iteration of the BD and Nested Benders Decomposition, theta is otherwise unconstrained, so this value ensures that the cost-to-variable is bounded. \nis_MIP::Bool - Whether the problem includes mixed integer variables in the subproblems. If the user does not set this value, the BendersAlgorithm constructor will detect this value by testing all subgraphs that are not the root subgraph (note that the root subgraph can have mixed integer variables and still set is_MIP to false). This argument determines when the backward pass occurs. For LPs, the backward pass can occur at the same time as the forward pass, but for MILPs, the backward pass is performed separately (and can be parallelized). ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"note: Note\nIf the objective value of a subproblem can be negative, it is important to set M to be less than zero. Otherwise, you can get lower bounds that are greater than upper bounds and the algorithm will not work. ","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"The run_algorithm! solves a BendersAlgorithm object. There are two additional keyword arguments you can set with run_algorithm!","category":"page"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"output::Bool - Whether to output the upper and lower bounds and the gap at each iteration of the algorithm\nrun_gc::Bool - Whether to run the garbage collector at the end of each iteration. Could potentially help with some memory issues. ","category":"page"},{"location":"PlasmoBenders/solver/#Two-Stage-Problem-Implementations","page":"Solver Options","title":"Two-Stage Problem Implementations","text":"","category":"section"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"Some solver options are only implemented for two-stage problems (what could be considered \"traditional\" Benders problems). These include parallelize_benders, regularize, and feasibility_cuts. Future development can include extending these to problems with three or more stages. ","category":"page"},{"location":"PlasmoBenders/solver/#Reporting-Issues","page":"Solver Options","title":"Reporting Issues","text":"","category":"section"},{"location":"PlasmoBenders/solver/","page":"Solver Options","title":"Solver Options","text":"If you encounter issues with PlasmoBenders, please open issues on Github's issue tracker. ","category":"page"},{"location":"PlasmoBenders/graph_structure/#Graph-Structure-for-PlasmoBenders","page":"Exploiting Graph Structure","title":"Graph Structure for PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"The graph structure defined by the user determines how the Benders Decomposition (BD) or Nested Benders Decomposition (NBD) algorithms are applied for the given problem. One of the strengths of Plasmo is that it provides flexibility in structuring problems and provides users with flexibility in building the graphs. Below, we will highlight some basic points about the graph structure chosen by the user. Further details can be found in our preprint here.","category":"page"},{"location":"PlasmoBenders/graph_structure/#Subproblem-Representation","page":"Exploiting Graph Structure","title":"Subproblem Representation","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"PlasmoBenders applies BD and NBD based on the graph structure defined by the user, and we note here the objects that PlasmoBenders.jl uses for subproblems. Under previous versions of Plasmo (v0.5.4 and earlier), both nodes and subgraphs could be solved independently. Newer releases of Plasmo (v0.6 and on) are more sub-graph centric, and subgraphs are intended to be the \"subproblem\" objects. Plasmo supports nesting graphs within other graphs, such that you can have any \"level\" of nested graphs in a given OptiGraph. Any subgraph can be \"aggregated\" to form a node (i.e., the optimization problem on a graph can equivalently be represnted with a single node). For a given OptiGraph, mathcalG, PlasmoBenders expects the graph to be partitioned into subgraphs (i.e., all nodes in the mathcalG are contained on a subgraph), and these subgraphs are treated as the subproblems. Note that each of these subgraphs could likewise have nested subgraphs within them, but PlasmoBenders does not operate on these additional nested subgraphs. Thus, in the BendersAlgorithm, there are two required arguments: the optigraph mathcalG and a subgraph of mathcalG which will serve as the root subgraph. ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"It is possible that a user may want to use nodes as subproblems instead of subgraphs. PlasmoBenders provides a constructor function for this case and expects each node in the graph to be a subproblem. In this case, the user can pass a node of the graph to the BendersAlgorithm constructor function. However, PlasmoBenders is designed to only operate with subgraphs, so in this node-based case, the graph will be partitioned into subgraphs with each node being on a separate subgraph. ","category":"page"},{"location":"PlasmoBenders/graph_structure/#Required-Graph-Structure","page":"Exploiting Graph Structure","title":"Required Graph Structure","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Both BD and NBD require the subgraphs to form a tree structure. This means that there are no cycles among the subgraphs. In other words, if you start at any subgraph i and move along the edges of the graph to any other subgraph j, you cannot return to subgraph i without traversing the same subgraphs as you did to reach subgraph j. PlasmoBenders, in constructing the BendersAlgorithm object, will check structure and error out if the structure is not correct. The root subgraph specified by the user serves as a \"starting point\" for the graph structure, and each subgraph will then be placed into stages, with the root subgraph as the first stage. The second stage is all subgraphs connected by an edge to the root subgraph, the third stage is all subgraphs connected to subgraphs in stage two that does not include previous stages, and so forth. BD is a specific case of NBD where there are only two stages. These structures can be visualized as below, where the nodes aligned vertically can be considered in the same stage: ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: graph_structure)","category":"page"},{"location":"PlasmoBenders/graph_structure/#Building-the-Graph-Structure","page":"Exploiting Graph Structure","title":"Building the Graph Structure","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Some structures may initially look unfit for BD or NBD, but the flexibility in structuring and partitioning graphs provided by Plasmo can create the required structures. For instance, consider the following graph, where each \"node\" here can be considered its own subgraph.","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: grid graph)","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"This problem can be partitioned into different subgraphs to form the required tree structure. For instance, you can see below different partitioning schemes that result in different tree structures that can then be used for PlasmoBenders. Note that the dotted lines represent new subgraphs formed by partitioning.","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"(Image: grid graph partitioned)","category":"page"},{"location":"PlasmoBenders/graph_structure/#Algorithm-Performance","page":"Exploiting Graph Structure","title":"Algorithm Performance","text":"","category":"section"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"Importantly, how the algorithm performs will be dependent on the structure defined by a user. In the above example, each of the given partitionings could result in different algorithm performance. PlasmoBenders generalizes the BD and NBD algorithms to graph structure, but ther performance of these algorithms is dependent in large part on the mathematical problems that exist on the subgraphs. For instance, the choice of root graph will dictate which subgraphs receive cutting planes. Even in the case of two subgraphs connected by an edge, either subgraph could be treated as the root subgraph (or the master problem of BD). However, the master problem of BD is often deliberately chosen (e.g., it may contain all of the integer variables), and choosing one subgraph as the root graph over the other could drastically impact algorithm performance. ","category":"page"},{"location":"PlasmoBenders/graph_structure/","page":"Exploiting Graph Structure","title":"Exploiting Graph Structure","text":"The user is therefore advised to use prior knowledge about their problem in choosing the root graph. Understanding the full impacts of the root graph choice or developing methods for choosing the root graph is an open area that, to our knowledge, has not yet been explored. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Storage-Operation","page":"Storage Operation","title":"Storage Operation","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This example is a simple example highlighting how PlasmoBenders can be applied to solve a temporal problem using Nested Benders Decomposition (Dual Dynamic Programming).","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Problem-Formulation","page":"Storage Operation","title":"Problem Formulation","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The example below is a simplified storage operation problem, where a raw material can be purchased and converted to a product and sold. The price of the product is variable, so it is most economical to store the product at times of low price and sell at times of high price. This problem can be considered a \"multi-scale\" problem because it is making decisions at each time point while having to consider longer-term product prices. The mathematical problem is as follows: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"beginalign*\n    min  sum_t=1^T c^raw_t u^raw_t - c^sell_t x^sell_t \n    textrmst  x^store_t+1 - x^store_t = x^save_t quad t = 1  T-1\n     x^save_t + x^sell_t - alpha cdot  u_t^raw = 0 quad t = 1  T \n     0 le x^store_t le overlined^store quad t = 1  T \n     0 le x^sell_t le overlined^sell quad t = 1  T \n     underlined^save le x^save_t le overlined^save quad t = 1  T \n     x^store_1 = barx^store\nendalign*","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Here, underlined and overlined are the upper and lower bounds on their respective variables, x^store_t is the amount of product in storage at time t, x^save_t is the amount of product sent to storage (can be negative), x^sell_t is the amount of product sold, u^raw_t is the amount of raw material purchased, c^sell_t is the price for product at time t, c^raw is the (constant) cost of raw material purchased, and alpha is a conversion factor from raw material to product. The first constraint is a mass balance on the storage, so that x^save_t represents the change in storage at time t. The second constraint is a mass balance on product at time t, which ensures that any product generated (alpha u^raw_t) must either be sold or sent to storage. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Modeling-the-Problem-with-Plasmo","page":"Storage Operation","title":"Modeling the Problem with Plasmo","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This problem can be modeled as a linear graph using Plasmo. We will represent each time point as a node in the graph, with T = 20 total nodes.  The code for building this problem is shown below: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Set problem data\nN = 20\nx_price = fill(5, N); u_cost = fill(20, N)\nx_price[6:10] .= 20; x_price[16:20] .= 50\n\n# Define OptiGraph and ndoes\ngraph = OptiGraph()\n@optinode(graph, nodes[1:N])\n\n# Fill each node with variables and constraints\nfor (j, node) in enumerate(nodes)\n    @variable(node, 0 <= x_storage <= 100)\n    @variable(node, 0 <= x_sell <= 50)\n    @variable(node, -20 <= x_save <= 20)\n    @variable(node, 0 <= u <= 25)\n\n    @constraint(node, x_save + x_sell - 2 * u == 0)\n    @objective(node, Min, -x_sell * x_price[j] + u * u_cost[j])\nend\n\n# Set initial storage value\n@constraint(nodes[1], nodes[1][:x_storage] == 10)\n\n# Define linking constraints for storage\n@linkconstraint(graph, [i = 1:(N - 1)], nodes[i + 1][:x_storage] - nodes[i][:x_storage] == nodes[i][:x_save])","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The above problem results in the following shape: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: 20node graph)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This problem is a simple LP and could be solved directly with a LP solver. However, we will solve this problem using Nested Benders Decomposition to highlight how the decomposition scheme works. We will partition this problem into four subproblems, each with five nodes. This can be done with the code below:","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"node_membership_vector = zeros(Int, N)\nnode_membership_vector[1:5]   .= 1\nnode_membership_vector[6:10]  .= 2\nnode_membership_vector[11:15] .= 3\nnode_membership_vector[16:20] .= 4\n\npartition = Plasmo.Partition(graph, node_membership_vector)\n\napply_partition!(graph, partition)\n\nfor subgraph in local_subgraphs(graph)\n    set_to_node_objectives(subgraph)\nend","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The resulting problem can be visualized as: ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: 20node partitioned graph)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Solving-with-PlasmoBenders","page":"Storage Operation","title":"Solving with PlasmoBenders","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The subgraphs have a (linear) tree structure, so we can pass this graph to PlasmoBenders' BendersAlgorithm constructor and solve it with Nested Benders Decomposition. This also requires setting a \"root subgraph.\" We will set the first subgraph as the root subgraph, but any of the subgraphs could be used. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\n\nroot_graph = local_subgraphs(graph)[1]\nbenders_alg = BendersAlgorithm(graph, root_graph, solver = solver)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"The Nested Benders scheme is able to reach the optimal solution after 5 iterations. The bounds and gap are shown below.","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"(Image: NBD_operation)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Note that the first iteration returns an upper bound that is well above the optimal. The first iteration of the solve is performing a \"receding-horizon\" approach, where each subgraph is solved in series and the optimal solution passed to the next subgraph. This results in a sub optimal solution since each problem is not \"seeing\" the future prices of the product. The cutting planes that are formed after each iteration essentially help provide the previous subgraphs with knowledge of how their solution impacts the solution of future subproblems, which results in the upper bound eventually converging to the true solution. ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/#Querying-Solutions","page":"Storage Operation","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"PlasmoBenders provides access to API functions for querying the optimal solution from the BendersAlgorithm object. We can query the solution by calling ","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.objective_value(benders_alg)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"which returns the best upper bound. We can query the lower bound by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.dual_objective_value(benders_alg)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"This lower bound can be less than the upper bound for MIP problems since there can be a duality gap. We can also query the relative gap by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"relative_gap(benders_alg)","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"Individual variable values can be retrieved by calling","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.value(benders_alg, graph[:nodes][1][:x_sell])","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"In addition, JuMP.value has been extended to also take a vector of variables rather than just a single variable, so we can also call","category":"page"},{"location":"PlasmoBenders/storage_tutorial/","page":"Storage Operation","title":"Storage Operation","text":"JuMP.value(benders_alg, all_variables(graph))","category":"page"},{"location":"PlasmoSchwarz/introduction/#PlasmoSchwarz.jl","page":"Introduction","title":"PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"PlasmoSchwarz.jl is a custom decomposition-based solver that exploits the graph structure defined for a Plasmo.jl OptiGraph and applies an overlapping Schwarz decomposition based on the user-defined structure. The algorithm is outlined in the paper \"A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl\" and in Prof. Sungho Shin's PhD Dissertation, \"Graph-Structured Nonlinear Programming: Properties and Algorithms\". ","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"Schwarz decomposition is an iterative algorithm takes advantage of Plasmo.jl's subgraph structuring capabilities by partitioning an optimization problem into separate subgraphs. The subgraphs can then be expanded to overlap with other subgraphs, and a single iteration of the algorithm solves each subgraph, which can be done in parallel. After optimization, solutions around the overlapping regions are shared between subgraphs and used within the algorithm to help the subgraphs converge to the solution of the overall problem. Schwarz decomposition does not support integer variables. Further, in practice, convergence of PlasmoSchwarz is dependent on problem formulation and the degree of overlap between problems. Convergence is not guaranteed, but primal and dual values can be used to detect whether a local solution has been reached. ","category":"page"},{"location":"PlasmoSchwarz/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/plasmo-dev/PlasmoAlgorithms.jl/tree/main/lib/PlasmoSchwarz.git\"))","category":"page"},{"location":"PlasmoSchwarz/introduction/#Citing-PlasmoSchwarz.jl","page":"Introduction","title":"Citing PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"If you find Plasmo.jl useful for your work, you may cite the manuscript as:","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"@article{Jalving2022,\n  title={A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\n  author={Jordan Jalving and Sungho Shin and Victor M. Zavala},\n  journal={Mathematical Programming Computation},\n  year={2022},\n  volume={14},\n  pages={699 - 747},\n  doi={10.1007/s12532-022-00223-3}\n}","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"You can also access a freely available pre-print.","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"There are also details on this algorithm in Prof. Sungho Shin's PhD dissertation here:","category":"page"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"@book{shin2021graph,\n  title={Graph-Structured Nonlinear Programming: Properties and Algorithms},\n  author={Shin, Sungho},\n  year={2021},\n  publisher={The University of Wisconsin-Madison}\n}","category":"page"},{"location":"PlasmoSchwarz/introduction/#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"PlasmoSchwarz/introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"quickstart.md\"\n    \"algorithm.md\"\n    \"api_docs.md\"\n    ]\nDepth = 2","category":"page"},{"location":"PlasmoBenders/introduction/#PlasmoBenders.jl","page":"Introduction","title":"PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"PlasmoBenders.jl is a custom decomposition-based solver that exploits the graph structure defined for a Plasmo.jl OptiGraph and applies Benders or Nested Benders Decomposition based on the user-defined structure (i.e., it detects the copmlicating variables based on the graph structure). The algorithm used by PlasmoBenders.jl is outlined in the manuscript Graph-Based Modeling and Decomposition of Hierarchical Optimization Problems. In this way, PlamsoBenders implements these decomposition approaches automatically for the user. ","category":"page"},{"location":"PlasmoBenders/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"PlasmoBenders\")","category":"page"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"or alternatively from the Julia package manager by performing the following:","category":"page"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"pkg> add PlasmoBenders","category":"page"},{"location":"PlasmoBenders/introduction/#Citing-PlasmoBenders.jl","page":"Introduction","title":"Citing PlasmoBenders.jl","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"If you find PlasmoBenders.jl useful for your work, you may cite the preprint as:","category":"page"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"@article{cole2025,\n  title={Graph-Based Modeling and Decomposition of Hierarchical Optimization Problems},\n  author={David L. Cole and Filippo Pecci and Omar J. Guerra and Harsha Gangammanavar and Jesse D. Jenkins and Victor M. Zavala},\n  journal={arXiv preprint arXiv:2501.02098},\n  year={2025}\n}","category":"page"},{"location":"PlasmoBenders/introduction/#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"PlasmoBenders/introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"algorithm.md\"\n    \"quickstart.md\"\n    \"solver.md\"\n    \"graph_structure.md\"\n    \"api_docs.md\"\n    \"storage_tutorial.md\"\n    ]\nDepth = 2","category":"page"},{"location":"PlasmoSchwarz/algorithm/#Solution-Algorithm-for-PlasmoSchwarz.jl","page":"Algorithm","title":"Solution Algorithm for PlasmoSchwarz.jl","text":"","category":"section"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Schwarz Decomposition is an iterative algorithm takes advantage of Plasmo.jl's subgraph structuring capabilities by partitioning an optimization problem into separate subgraphs. The subgraphs can then be expanded to overlap with other subgraphs, and a single iteration of the algorithm solves each subgraph, which can be done in parallel. After optimization, solutions around the overlapping regions are shared between subgraphs and used within the algorithm to help the subgraphs converge to the solution of the overall problem. Schwarz decomposition does not support integer variables. Further, in practice, convergence of PlasmoSchwarz is dependent on problem formulation and the degree of overlap between problems. Convergence is not guaranteed, but primal and dual values can be used to detect whether a local solution has been reached. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/#Schwarz-Decomposition","page":"Algorithm","title":"Schwarz Decomposition","text":"","category":"section"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Schwarz Decomposition can be applied to graph-structured problems defined in Plasmo.jl The overall graph structure in Plasmo.jl has the form","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  sum_n in mathcalN(mathcalG) f_n (x_n) \n    textrmst  x_n in mathcalX_n n in mathcalN(mathcalG) \n     g_e(x_n _n in mathcalN(e)) = 0 e in mathcalE(mathcalG)\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, x_n are the variables stored on node n, mathcalN(mathcalG) represents the set of nodes on graph mathcalG, mathcalE(mathcalG) represents the set of edges on graph mathcalG, and mathcalN(E) are the nodes connected by edge e. Thus, the first constraint set are the local constraints (stored on each node) and the second constraint set are the linking constraints for constraints on two or more nodes. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Further details of the algorithm can be found in the original Plasmo.jl paper here, but we will give an overview of the algorithm here. A graph mathcalG can be partitioned into N subgraphs notated by  mathcalSG_i ^N_i=1. These subgraphs can be expanded (meaning that they will now include nodes within a prescribed distance of nodes in the original subgraph) to obtain expanded subgraphs notated by  mathcalSG_i ^N_i=1. Under Schwarz Decomposition, the constraints on the incident edges of the expanded subgraphs can be enforced using the previous iteration's solutions from the adjacent subgraphs. The formulation for a given subgraph, mathcalSG_i is given by:","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\n    min  sum_n in mathcalN(mathcalSG_i) f_n (x_n) - sum_e in mathcalI_1(mathcalSG_i) (lambda_e^k)^top g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i)) \n    textrmst  x_n in mathcalX_n n in mathcalN(mathcalSG_i) \n     g_e(x_n _n in mathcalN(e)) = 0 e in mathcalE(mathcalSG_i) \n     g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i)) = 0 e in mathcalI_2(mathcalSG_i)\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here, (cdot)^k denotes the iteration counter, lambda_e denotes the dual variable on their respective constraints, and mathcalI(mathcalSG_i) denotes the set of incident edges (i.e., edges which contain nodes in the overlapped subgraph and outside of the overlapped subgraph). The sets mathcalI_1 and mathcalI_2 denote how the incident linking constraints are formulated in the subproblem (as either primal or dual coupled). ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"In the thesis of Prof. Sungho Shin, it was also shown to improve convergence to include an augmented penalty term in the objective, and this is included in PlasmoSchwarz. The objective therefore also gets updated with the augmented term ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"beginalign*\nsum_e in mathcalI_1(mathcalSG_i) mu frac12 g_e(x_n _n in mathcalN(e) capmathcalN(mathcalSG_i) x_n^k _nin mathcalN(e) setminus mathcalN(mathcalSG_i))\nendalign*","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"where mu is a parameter that can be set by the user. ","category":"page"},{"location":"PlasmoSchwarz/algorithm/","page":"Algorithm","title":"Algorithm","text":"Convergence of the algorithm is determined by primal and dual infeasibility which is computed at each iteration. The primal feasibility is determined by the incident linking constraints being feasible between the different subproblems, and the dual infeasibility is determined by the difference in the dual variables of the link constraints in the overlapping regions. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart gives a brief overview of the functions needed for using PlasmoSchwarz to solve optimization problems defined in Plasmo. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Once PlasmoSchwarz has been installed, you can use it from a Julia session using ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using PlasmoSchwarz","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz also requires defining a graph with Plasmo, and we will need a solver for the subproblems. We will use Ipopt. These packages will also need to be loaded","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using Plasmo, Ipopt","category":"page"},{"location":"PlasmoSchwarz/quickstart/#PlasmoSchwarz-Overview","page":"Quickstart","title":"PlasmoSchwarz Overview","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz is an iterative algorithm that solves overlapping subproblems and then shares information between the subproblems to help converge to the overall solution. The structure that PlasmoSchwarz \"sees\" is either defined by the user by partitioning into subgraphs or the partitioning can be done automatically using packages like Metis.jl or KaHyPar. The graph is passed to the SchwarzAlgorithm function which overlaps the graphs and updates the graphs as needed to apply Schwarz Decomposition. Schwarz Decomposition can then be applied by calling run_algorithm!. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/#Optimal-Control-Example","page":"Quickstart","title":"Optimal Control Example","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"To show how PlasmoSchwarz can be applied for solving a problem, we will show a simple example of an optimal control problem over 200 time steps. The problem can be written as ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"beginalign* \n    min  sum_t in mathcalT x_t^2 + u_t^2\n    textrmst  x_t+1 = x_t + u_t + d_t\n     x_0 = barx_o \n     x_t ge 0 \n     u_t ge underlineu\nendalign*","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, x are the states, u are the inputs, and d are disturbances. ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start by importing the required packages and defining problem parameters","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Plasmo, Ipopt\nusing PlasmoSchwarz\n\nT = 200             # number of time points\nd = sin.(1:T)       # a disturbance vector\nimbalance = 0.1     # partition imbalance\ndistance = 2        # expansion distance\nn_parts = 10        # number of partitions","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Next, we will create the OptiGraph and nodes. Each state and input variable will be represented by a node.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# create the optigraph\ngraph = Plasmo.OptiGraph()\n@optinode(graph, state[1:T])\n@optinode(graph, control[1:(T - 1)])\nfor (i, node) in enumerate(state)\n    @variable(node, x)\n    @constraint(node, x >= 0)\n    @objective(node, Min, x^2)\nend\nfor node in control\n    @variable(node, u)\n    @constraint(node, u >= -1000)\n    @objective(node, Min, u^2)\nend","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Next, we will set the initial value of the state and then link the state variables to the previous state and inputs.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# initial condition\nn1 = state[1]\n@constraint(n1, n1[:x] == 0)\n\n# dynamics\nfor i in 1:(T - 1)\n    @linkconstraint(graph, state[i + 1][:x] == state[i][:x] + control[i][:u] + d[i])\nend","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Now, we can define the sub-solver that will be used on the individual subproblem subgraphs, and we can then construct the SchwarzAlgorithm object.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"# subproblem optimizer\nsub_optimizer = Plasmo.optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\n\n# optimize using overlapping schwarz decomposition\noptimizer = SchwarzAlgorithm(\n    graph;\n    n_partitions=n_parts,\n    overlap_distance=1,\n    subproblem_optimizer=sub_optimizer,\n    max_iterations=100,\n    mu=10.0,\n)","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, we have not defined the partitions to be used, so the SchwarzAlgorithm function will do the partitioning internally using Metis.jl and then overlap each subgraph by a distance of 1. Now, we can run the algorithm by calling ","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"run_algorithm!(optimizer)","category":"page"},{"location":"PlasmoSchwarz/quickstart/#Querying-Solutions","page":"Quickstart","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoSchwarz.jl provides API functions for querying solutions and information from the SchwarzAlgorithm object. To query the objective value, termination status, or solve time, we can use","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Plasmo.objective_value(optimizer)\nPlasmo.termination_status(optimizer)\nPlasmo.solve_time(optimizer)","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"The primal and dual variables can be queried by calling value or dual with the first argument being the SchwarzAlgorithm object","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"Plasmo.value(optmizer, state[1][:x])\ncons = all_constraints(graph)\nPlasmo.dual(optimizer, cons[1])","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"You can also access the primal and dual feasibility vectors by viewing the algorithm methods.","category":"page"},{"location":"PlasmoSchwarz/quickstart/","page":"Quickstart","title":"Quickstart","text":"prf = PlasmoSchwarz.calculate_primal_feasibility(optimizer)\nduf = PlasmoSchwarz.calculate_dual_feasibility(optimizer)","category":"page"},{"location":"PlasmoSchwarz/api_docs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"PlasmoSchwarz/api_docs/#API-Manual","page":"API Documentation","title":"API Manual","text":"","category":"section"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.Options","page":"API Documentation","title":"PlasmoSchwarz.Options","text":"Options\n\nConfiguration options for the algorithm.\n\nFields:\n\ntolerance::Float64: Convergence tolerance for primal and dual errors (default: 1e-4).\nmax_iterations::Int64: Maximum number of iterations to run (default: 1000).\nmu::Float64: Penalty parameter for the augmented Lagrangian (default: 1.0).\noverlap_distance::Int64: Distance for overlap in subproblem expansion (default: 1).\nuse_node_objectives::Bool: Whether to use node-specific objectives instead of a global graph objective (default: true).\nsubproblem_optimizer: The optimizer to use for solving subproblems (default: nothing).\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SchwarzAlgorithm","page":"API Documentation","title":"PlasmoSchwarz.SchwarzAlgorithm","text":"SchwarzAlgorithm{GT<:Plasmo.AbstractOptiGraph}\n\nRepresents a Schwarz-based optimization algorithm applied to a partitioned graph.\n\nFields:\n\ngraph::GT: The global optimization graph passed to the algorithm.\nsubproblems::Vector{GT}: A list of subgraphs representing the (expanded) subproblems.\nelement_subproblem_map::Dict{Plasmo.OptiElement,GT}: Maps elements in the graph to their associated subproblems.\nobjective_func::Plasmo.AbstractJuMPScalar: The global objective function for the graph.\noptions::Options: Configuration options for the algorithm.\ninitialized::Bool: Whether the algorithm has been initialized.\nstatus::MOI.TerminationStatusCode: The current status of the algorithm.\nerr_pr::Union{Nothing,Float64}: Current primal error.\nerr_du::Union{Nothing,Float64}: Current dual error.\nobjective_value::Union{Nothing,Float64}: Current objective value.\niteration::Int64: Current iteration count.\nprimal_error_iters::Vector{Float64}: History of primal errors per iteration.\ndual_error_iters::Vector{Float64}: History of dual errors per iteration.\nobjective_iters::Vector{Float64}: History of objective values per iteration.\nsolve_time::Float64: Total solve time.\ntimers::Timers: Timers to measure performance metrics.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SchwarzAlgorithm-Tuple{OptiGraph, Vector{OptiGraph}}","page":"API Documentation","title":"PlasmoSchwarz.SchwarzAlgorithm","text":"SchwarzAlgorithm(graph::OptiGraph, expanded_subgraphs::Vector{OptiGraph}; kwargs...)\n\nCreate an algorithm instance by providing the subproblems directly.\n\nSchwarzAlgorithm(graph::OptiGraph, partition::Plasmo.Partition; kwargs...)\n\nCreate an algorithm instance by providing a valid Plasmo.Partition.\n\nSchwarzAlgorithm(graph::OptiGraph, partition::Plasmo.Partition; kwargs...)\n\nCreate an algorithm instance and use Metis internally to create partitions.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.SubProblemData","page":"API Documentation","title":"PlasmoSchwarz.SubProblemData","text":"SubProblemData{GT<:Plasmo.AbstractOptiGraph}\n\nHolds data specific to a subproblem in the optimization graph.\n\nFields:\n\nrestricted_subgraph::GT: The subgraph representing the \"restricted\" subproblem. This is the subproblem before adding overlap.\nincident_variable_map::OrderedDict{NodeVariableRef,GT}: Maps incident variables to their owning subgraphs.\nincident_constraint_map::OrderedDict{EdgeConstraintRef,GT}: Maps incident constraints to their owning subgraphs.\nprimal_values::OrderedDict{NodeVariableRef,Float64}: Stores the current primal variable values.\ndual_values::OrderedDict{EdgeConstraintRef,Float64}: Stores the current dual variable values.\nprimal_parameters::OrderedDict{NodeVariableRef,NodeVariableRef}: Maps primal variables to their parameter values.\ndual_parameters::OrderedDict{EdgeConstraintRef,NodeVariableRef}: Maps dual variables to their parameter values.\nnode_objectives::OrderedDict{OptiNode,Plasmo.AbstractJuMPScalar}: Objective functions associated with nodes in the subproblem.\nobjective_function::Union{Nothing,Plasmo.AbstractJuMPScalar}: The total objective function for the subproblem, including penalties.\nlast_termination_status::MOI.TerminationStatusCode: The termination status from the last solve.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.Timers","page":"API Documentation","title":"PlasmoSchwarz.Timers","text":"Timers\n\nSimple data structure to track the timing of various stages of the SchwarzAlgorithm.\n\nFields:\n\nstart_time::Float64: Time when the algorithm starts.\ninitialize_time::Float64: Time taken to initialize the algorithm.\neval_objective_time::Float64: Time taken to evaluate the objective function.\neval_primal_feasibility_time::Float64: Time taken to evaluate primal feasibility.\neval_dual_feasibility_time::Float64: Time taken to evaluate dual feasibility.\ncommunicate_time::Float64: Time spent in inter-subproblem communication.\nupdate_subproblem_time::Float64: Time taken to update subproblems.\nsolve_subproblem_time::Float64: Time taken to solve subproblems.\ntotal_time::Float64: Total time for the entire process.\n\n\n\n\n\n","category":"type"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._check_tolerance-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._check_tolerance","text":"_check_tolerance(algorithm::SchwarzAlgorithm) -> Bool\n\nCheck if the primal or dual residuals exceed the specified tolerance. This  determines whether the algorithm should continue iterating.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._extract_constraints-Tuple{Vector{Vector{OptiEdge}}}","page":"API Documentation","title":"PlasmoSchwarz._extract_constraints","text":"_extract_constraints(subgraph_boundary_edges::Vector{Vector{OptiEdge}}) -> Vector{Vector{ConstraintRef}}\n\nRetrieve the constraints associated with boundary edges for a set of subgraphs.  For each subgraph, the constraints tied to its boundary edges are collected.\n\nArgs:\n\nsubgraph_boundary_edges::Vector{Vector{OptiEdge}}: A vector of vectors,  where each inner vector contains the boundary edges of a specific subgraph.\n\nReturns:     A vector of vectors, where each inner vector contains the constraints      associated with the boundary edges of a specific subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._extract_node_objectives-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._extract_node_objectives","text":"_extract_node_objectives(algorithm::SchwarzAlgorithm)\n\nExtracts separable objective terms from the global graph and assigns them to the nodes  of each subproblem's restricted subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._find_boundary_edges-Tuple{OptiGraph, Vector{OptiGraph}}","page":"API Documentation","title":"PlasmoSchwarz._find_boundary_edges","text":"_find_boundary_edges(graph::OptiGraph, subgraphs::Vector{OptiGraph}) -> Vector{Vector{OptiEdge}}\n\nIdentify the boundary edges for a set of subgraphs within a given hypergraph.  Boundary edges are those incident to nodes at the interface between the subgraphs  and the rest of the graph.\n\nArgs:\n\ngraph::OptiGraph: The main graph containing the subgraphs and edges.\nsubgraphs::Vector{OptiGraph}: A vector of subgraphs for which boundary edges  need to be identified.\n\nReturns:     A vector of vectors, where each inner vector contains the boundary edges      associated with a specific subgraph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._formulate_objective_penalty-Tuple{OptiGraph, Float64}","page":"API Documentation","title":"PlasmoSchwarz._formulate_objective_penalty","text":"_formulate_objective_penalty(expanded_subgraph::OptiGraph, mu::Float64)\n\nAdds dual penalties and an augmented Lagrangian penalty term to the objective of the  given subproblem.\n\nArgs:\n\nexpanded_subgraph: The subproblem graph with overlap regions.\nmu: The penalty parameter for the augmented Lagrangian method.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._get_subproblem-Tuple{SchwarzAlgorithm, Union{OptiEdge{var\"#s6\"} where var\"#s6\"<:Plasmo.AbstractOptiGraph, OptiNode{var\"#s7\"} where var\"#s7\"<:Plasmo.AbstractOptiGraph}}","page":"API Documentation","title":"PlasmoSchwarz._get_subproblem","text":"_get_subproblem(algorithm::SchwarzAlgorithm, element::Plasmo.OptiElement) -> GT\n\nRetrieves the subproblem associated with a given element in the optimization graph.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._initialize_subproblem_objectives-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz._initialize_subproblem_objectives","text":"_initialize_subproblem_objectives(algorithm::SchwarzAlgorithm)\n\nInitializes the objective functions for each subproblem in the algorithm. \n\nThis function either sets node objectives directly, if specified, or extracts and assigns the graph's separable objective terms to the subproblems. \n\nAdditionally, augmented Lagrangian penalty terms are added to the objectives.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._is_hierarchical-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._is_hierarchical","text":"_is_hierarchical(graph::OptiGraph)\n\nCheck whether the given graph is hierarchical (i.e. contains nodes and subgraphs.)\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._retrieve_neighbor_values-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._retrieve_neighbor_values","text":"_retrieve_neighbor_values(subproblem_graph::OptiGraph)\n\nFetches primal and dual values from neighboring subproblems linked via incident variables and constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._solve_subproblem-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._solve_subproblem","text":"_solve_subproblem(subproblem_graph::OptiGraph)\n\nSolves an individual subproblem and logs its termination status.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._update_objective_penalty-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._update_objective_penalty","text":"_update_objective_penalty(expanded_subgraph::OptiGraph)\n\nUpdates the terms in the subproblem's objective based on the current primal and dual values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz._update_subproblem-Tuple{OptiGraph}","page":"API Documentation","title":"PlasmoSchwarz._update_subproblem","text":"_update_suproblem(subproblem_graph::OptiGraph)\n\nUpdates the objective penalty terms of the given subproblem based on the current neighbor values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_dual_feasibility-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_dual_feasibility","text":"calculate_dual_feasibility(algorithm::SchwarzAlgorithm) -> Vector{Float64}\n\nEvaluate the dual feasibility of the linking constraints defined over the  algorithm's graph. For each linking constraint, the function calculates the  difference between the maximum and minimum dual values across subproblems.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the graph and linking constraints.\n\nReturns:     A vector of dual residuals for the linking constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_objective_value-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_objective_value","text":"calculate_objective_value(algorithm::SchwarzAlgorithm) -> Float64\n\nEvaluate the objective value defined over the algorithm's graph. The function uses  the current variable values from the subproblems to compute the overall objective.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the objective function  and subproblem mappings.\n\nReturns:     The evaluated objective value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.calculate_primal_feasibility-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.calculate_primal_feasibility","text":"calculate_primal_feasibility(algorithm::SchwarzAlgorithm) -> Vector{Float64}\n\nEvaluate the primal feasibility of the linking constraints defined over the  algorithm's graph. This is done by checking the residuals between the linking  constraints and their expected values based on the subproblem solutions.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object containing the graph and linking constraints.\n\nReturns:     A vector of primal residuals for the linking constraints.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.check_valid_problem-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.check_valid_problem","text":"check_valid_problem(algorithm::SchwarzAlgorithm) -> Bool\n\nValidates the setup of an optimization problem for the specified algorithm. This function performs the following checks:\n\nEnsures a subproblem optimizer is defined in the algorithm options.\nValidates the consistency of subproblem graphs with their respective restricted subgraphs.\nConfirms that the objective function is separable. Non-separable objectives are currently unsupported.\nVerifies that the optimization graph does not exhibit a hierarchical structure, which is unsupported.\n\nIf some of these checks fail, the algorithm's status is set to MOI.INVALID_MODEL, and an appropriate error is thrown.\n\nNotes:\n\nAdditional validations planned for future implementations:\nChecking for non-contiguous partitions.\nEnsuring there is sufficient overlap (at least 1) in expanded graphs.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.do_iteration-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.do_iteration","text":"do_iteration(algorithm::SchwarzAlgorithm)\n\nPerforms a single iteration of the algorithm. This involves:\n\nSolving each subproblem.\nCommunicating primal and dual values between subproblems.\nUpdating subproblem objectives, penalties, and neighbor values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.eval_iteration-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.eval_iteration","text":"eval_iteration(algorithm::SchwarzAlgorithm; save_iteration::Bool=true)\n\nEvaluate the current iterate of the algorithm by calculating primal and dual  feasibility, as well as the objective value. Optionally, the iterate values  can be stored internally for tracking progress.\n\nArgs:\n\nalgorithm::SchwarzAlgorithm: The algorithm object representing the current optimization state.\nsave_iteration::Bool: Whether to save the iterate values. Default is true.\n\nReturns:     Nothing. Updates the algorithm state with current feasibility and objective values.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.initialize!-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.initialize!","text":"initialize!(algorithm::SchwarzAlgorithm)\n\nInitializes the algorithm by validating the input problem and setting up subproblems. This includes:\n\nValidating the global graph and subproblem consistency.\nAssigning incident constraints and variables.\nSetting up objective penalties for the subproblems.\n\nThrows:\n\nArgumentError if the algorithm fails to initialize.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.reset_iterations-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.reset_iterations","text":"reset_iterations(algorithm::SchwarzAlgorithm)\n\nResets the algorithm's iteration counters and initializes the timers. Also sets up optimizers for each subproblem.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoSchwarz/api_docs/#PlasmoSchwarz.run_algorithm!-Tuple{SchwarzAlgorithm}","page":"API Documentation","title":"PlasmoSchwarz.run_algorithm!","text":"run_algorithm!(algorithm::SchwarzAlgorithm)\n\nExecute the optimization algorithm, iteratively solving subproblems and updating  the solution until convergence or a stopping criterion is met.\n\n\n\n\n\n","category":"method"},{"location":"PlasmoBenders/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart gives a brief overview of the functions needed for using PlasmoBenders to solve optimization problems defined in Plasmo. The example below will include a simple graph with three subproblems that we can solve with either Benders Decomposition (BD) or Nested Benders Decomposition (NBD). We will define the problem and then show how to create and solve the BendersAlgorithm object.","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Once PlasmoBenders has been installed, you can use it from a Julia session using ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using PlasmoBenders","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoBenders also requires defining a graph with Plasmo, and we will need a solver for the subproblems. We will use HiGHS. These packages will also need to be loaded","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using Plasmo, HiGHS","category":"page"},{"location":"PlasmoBenders/quickstart/#Required-Structure","page":"Quickstart","title":"Required Structure","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"BD and NBD can exploit problem structure, and they require a specific graph structure in order to be applied. PlasmoBenders uses subgraphs as the subproblems, and the subgraphs must form a tree structure. This means that there are no cycles among the subgraphs. In other words, if you start at any subgraph i and move along the edges of the graph to any other subgraph j, you cannot return to subgraph i without traversing the same subgraphs as you did to reach subgraph j. PlasmoBenders, in constructing the BendersAlgorithm object, will check structure and error out if the structure is not correct.","category":"page"},{"location":"PlasmoBenders/quickstart/#Basic-OptiGraph","page":"Quickstart","title":"Basic OptiGraph","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"First, we will define a simple graph with 3 subgraphs. Each subgraph will serve as a subproblem of BD/NBD, and each will contain one node. The code below creates this initial graph. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Plasmo, HiGHS, PlasmoBenders\n\n# Define optigraphs\ng = OptiGraph(); g1 = OptiGraph()\ng2 = OptiGraph(); g3 = OptiGraph()\n\n# Define problem on first OptiGraph\n@optinode(g1, n)\n@variable(n, x[1:2] >= 0)\n@constraint(n, 2 * x[1] + x[2] == 3)\n@objective(n, Min, x[1] + 2 * x[2])\n\n# Define problem on second OptiGraph\n@optinode(g2, n)\n@variable(n, x >= 0)\n@objective(n, Min, 4 * x)\n\n# Define problem on third OptiGraph\n@optinode(g3, n)\n@variable(n, x >= 1)\n@objective(n, Min, x)\n\n# Add these OptiGraphs as subgraphs to the overall OptiGraph, g\nadd_subgraph!(g, g1); add_subgraph!(g, g2); add_subgraph!(g, g3)\n\n# Set subgraph objectives to be their node's objectives\nset_to_node_objectives(g1)\nset_to_node_objectives(g2)\nset_to_node_objectives(g3)\n\n# Create links between the subgraphs\n@linkconstraint(g0, g1[:n][:x][2] + g2[:n][:x] == 3)\n@linkconstraint(g0, g1[:n][:x][1] + g3[:n][:x] >= 1)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, subgraph 1 is connected to subgraphs 2 and 3 by the link constraints. Subgraphs 2 and 3 are not connected to each other","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nPlasmoBenders currently only works with the Min objective sense for subgraphs. If your subgraphs have Maximizations for objectives, it is recommended that you reformulate your objective so that max f(x) becomes min -f(x).","category":"page"},{"location":"PlasmoBenders/quickstart/#BendersAlgorithm-Object","page":"Quickstart","title":"BendersAlgorithm Object","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"The BendersAlgorithm object updates the subgraphs to have the required cost-to-go variables and variable copies (fixed from previous stages). The constructor requires two arguments: 1) the overall graph and 2) the subgraph that will serve as the \"root\" subgraph. The root subgraph is the \"master\" problem for BD or the first stage problem for NBD. The BendersAlgorithm constructor also supports several other key word arguments that are oulined in a separate page of the documentation. These include things like the maximum number of iterations, the convergence tolerance, or whether to use certain other options (e.g., regularization) within the solver. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Before creating the BendersAlgorithm object, we note that each subgraph requires a solver set on it. We will use HiGHS below, and we will set the output flag solver option to be false (this reduces the overall output and makes the BendersAlgorithm output more readable). We can either set the solver manually, or we can pass the solver to the BendersAlgorithm function using the keyward solver. To set the solver manually, we do","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nset_optimizer(g1, solver)\nset_optimizer(g2, solver)\nset_optimizer(g3, solver)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"We can now call the BendersAlgorithm function (and if we have not set the solver, we can do so when calling this function).","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nbenders_alg = BendersAlgorithm(g, g1, solver = solver)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Here, benders_alg is the optimizer object. It includes several attributes, including the upper and lower bounds at each iteration, solver options, a mapping of complicating variables to their subproblems, and dual and primal information from each iteration. ","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"Because PlasmoBenders requires a tree structure, we can actually set any subgraph as the root graph. Setting g1 as the root graph results in two stages (g1 in stage 1 and g2 and g3 in stage 2), but we could instead solve this problem with three stages by setting either g2 or g3 as the root graph by changing the second argument in the BendersAlgorithm function in the code above. ","category":"page"},{"location":"PlasmoBenders/quickstart/#Optimizing-the-BendersAlgorithm","page":"Quickstart","title":"Optimizing the BendersAlgorithm","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"The BendersAlgorithm object can be solved directly after initialization by calling run_algorithm!. This function has been extended from JuMP to solve the BendersAlgorithm object. The solution approach includes performing the forward and backward pass","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"run_algorithm!(benders_alg)","category":"page"},{"location":"PlasmoBenders/quickstart/#Querying-Solutions","page":"Quickstart","title":"Querying Solutions","text":"","category":"section"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"PlasmoBenders.jl provides API functions for querying solutions and information from the BendersAlgorithm object. Many of these are extended from JuMP. To query the objective, value, we can use","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.objective_value(benders_alg)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This returns the best upper bound. If PlasmoBenders has not converged to the requested tolerance, it will still return the best upper bound it has yet found. The lower bound can be queried by calling","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.dual_objective_value(benders_alg)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"This returns the value of the lower bound. In the case of MIP problems, it is possible that there is a MIP gap and that certain tolerances cannot be reached. To see the relative gap between the lower and upper bound (i.e., the absolute value of the difference between the upper and lower bounds, normalized by the upper bound), you can call","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"relative_gap(benders_alg)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"In addition, there is functionality for querying the solution corresponding to the best upper bound. Individual variable values can be queried by calling","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.value(benders_alg, var)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"where var is the variable reference. Variables can be queried from the graph by pointing to the node and then pointing to the variable reference. For instance, we can query x[1] from g1 by calling g1[:n][:x][1]. In addition, we note that the JuMP.value function can normally take a single argument of a variable, but the extension we provide requires two arguments, with the first argument specifying the BendersAlgorithm object. To query the solutions for a vector of variables, you can call","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"JuMP.value(benders_alg, vars)","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"where vars is a vector of variables, such as all_variables(g).","category":"page"},{"location":"PlasmoBenders/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nPlasmoBenders currently does not create a copy of the graph that is passed to the optimizer. This means that the user is discouraged from building the BendersAlgorithm object and then altering the problem structure. In addition, if a user creates the BendersAlgorithm object and then tries to optimize the graph or add to the graph, it may have unexpected solutions because of the addition of the cost-to-go variables and additional linking constraints. If the graph needs to be altered and the BendersAlgorithm re-solved, it is recommended that the original graph be recreated and a new BendersAlgorithm object built. ","category":"page"},{"location":"#PlasmoAlgorithms.jl","page":"Introduction","title":"PlasmoAlgorithms.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is a library of decomposition approaches in Julia that have been implemented for Plasmo.jl data structures. Plasmo is an open-source modeling package that constructs graph-structured optimization models. Plasmo is built on an abstraction called an OptiGraph, containing OptiNodes (with objectives, variables, and constraints) and OptiEdges (with constraints for variables on two or more nodes). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoAlgorithms is intended to include different decomposition approaches that can exploit the graph structure of an optimization, and the implementation of these algorithms is based upon the graph structure. Currently, the following are implemented in this repository: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Benders Decomposition is implemented through the package PlasmoBenders.jl that is contained in this repository. PlasmoBenders.jl applies Benders and Nested Benders Decompositions to a problem defined by the user in Plasmo. PlasmoBenders applies these decomposition approaches based on the structure defined by the graph, where the graph structure dictates the complicating variables for the algorithm. Benders can be used for LP and MILP problems.\nOverlapping Schwarz Decomposition is implemented throught he package PlasmoSchwarz.jl (formerly SchwarzOpt.jl). PlasmoSchwarz.jl uses a partitioned graph and overlaps the partitioned regions with their neighboring partitions. Each overlapped subgraph is optimized and information is then shared between the subgraphs. Overlapping Schwarz can be used for NLP problems. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other decomposition approaches could likewise be developed. We welcome contributions to the PlasmoAlgorithms suite. In addition, we encourage reporting issues and feature requests via the GitHub issue tracker..","category":"page"}]
}
